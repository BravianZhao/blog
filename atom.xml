<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>静水流深</title>
  
  <subtitle>当你的才华还撑不起你的野心时，你应该静下心去学习并实践</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jihuawisdom.cn/"/>
  <updated>2019-11-25T09:31:13.168Z</updated>
  <id>http://jihuawisdom.cn/</id>
  
  <author>
    <name>Bravian Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wsgi协议简单说明</title>
    <link href="http://jihuawisdom.cn/2019/11/25/wsgi%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://jihuawisdom.cn/2019/11/25/wsgi协议简单说明/</id>
    <published>2019-11-24T17:00:20.000Z</published>
    <updated>2019-11-25T09:31:13.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSGI-协议产生背景"><a href="#WSGI-协议产生背景" class="headerlink" title="WSGI 协议产生背景"></a>WSGI 协议产生背景</h1><p>在使用 python web 服务器动态产生大量 html 页面的时候，产生了把接收 http 请求、返回 http 响应和产生 HTML 页面的逻辑分开的需要。 通常把接收 http 请求、返回 http 响应 这部分逻辑叫 Web 服务器，动态产生 HTML 页面的逻辑叫 Web 应用。这就产生了 WSGI 接口协议，全称 Web Server Gateway Interface，WSGI 协议规定了Python Web 服务器和 Web应用之间通过什么方式相互调用。</p><a id="more"></a><h1 id="WSGI-协议规范和案例"><a href="#WSGI-协议规范和案例" class="headerlink" title="WSGI 协议规范和案例"></a>WSGI 协议规范和案例</h1><h2 id="WSGI-应用"><a href="#WSGI-应用" class="headerlink" title="WSGI 应用"></a>WSGI 应用</h2><p>WSGI 接口定义非常简单，它只要求 Web应用实现一个产生 HTML 页面数据的函数。</p><p>比如下面这个 Web 版本的 “Hello, web!”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</span><br></pre></td></tr></table></figure><ol><li>函数有两个参数，environ 里面保存的是 http 请求的相关信息，start_response 是一个回调函数，用来设置 http 响应的响应头</li><li>函数的返回值是 http 的响应体</li></ol><p>有了 WSGI 协议，Python Web 服务器专门负责，接收 http 请求、解析 http 请求、拼接 http 响应，返回 http 响应，Python Web 应用只需要负责动态产生 http 响应的内容。</p><h2 id="WSGI-服务器"><a href="#WSGI-服务器" class="headerlink" title="WSGI 服务器"></a>WSGI 服务器</h2><p>有了 WSGI 应用还需要 WSGI 服务器，Python 语言包已经提供了一个 WSGI 服务器的简单实现，用于测试和参考，这个 WSGI 服务器实现包叫做 wsgiref，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"><span class="comment"># 导入web应用的application函数</span></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器，IP地址为空，端口是8000，web应用函数是application</span></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">8000</span>, application)</span><br><span class="line"><span class="comment"># 开始监听HTTP请求</span></span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure><h2 id="Django框架中的WSGI"><a href="#Django框架中的WSGI" class="headerlink" title="Django框架中的WSGI"></a>Django框架中的WSGI</h2><p><img src="//jihuawisdom.cn/2019/11/25/wsgi协议简单说明/Django框架中的WSGI.png" alt="Django框架中的WSGI"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WSGI-协议产生背景&quot;&gt;&lt;a href=&quot;#WSGI-协议产生背景&quot; class=&quot;headerlink&quot; title=&quot;WSGI 协议产生背景&quot;&gt;&lt;/a&gt;WSGI 协议产生背景&lt;/h1&gt;&lt;p&gt;在使用 python web 服务器动态产生大量 html 页面的时候，产生了把接收 http 请求、返回 http 响应和产生 HTML 页面的逻辑分开的需要。 通常把接收 http 请求、返回 http 响应 这部分逻辑叫 Web 服务器，动态产生 HTML 页面的逻辑叫 Web 应用。这就产生了 WSGI 接口协议，全称 Web Server Gateway Interface，WSGI 协议规定了Python Web 服务器和 Web应用之间通过什么方式相互调用。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="wsgi" scheme="http://jihuawisdom.cn/tags/wsgi/"/>
    
      <category term="web" scheme="http://jihuawisdom.cn/tags/web/"/>
    
      <category term="webserver" scheme="http://jihuawisdom.cn/tags/webserver/"/>
    
      <category term="web框架" scheme="http://jihuawisdom.cn/tags/web%E6%A1%86%E6%9E%B6/"/>
    
      <category term="django" scheme="http://jihuawisdom.cn/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://jihuawisdom.cn/2019/09/10/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://jihuawisdom.cn/2019/09/10/Python基础/</id>
    <published>2019-09-09T16:16:49.000Z</published>
    <updated>2019-11-25T09:31:33.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Python基础入门"><a href="#1-Python基础入门" class="headerlink" title="1.Python基础入门"></a>1.Python基础入门</h1><h2 id="1-1计算机组成"><a href="#1-1计算机组成" class="headerlink" title="1.1计算机组成"></a>1.1计算机组成</h2><p>cpu 主要是用来进行运算和控制的</p><pre><code>- 运算，主要是算术运算（+、-、*、\）、比较运算（&gt;、&lt;、=、&gt;=、&lt;=）和逻辑运算（与或非），cpu所有运算使用的数据都来自于cpu内部的存储器（也叫寄存器，它和内存差不多也是一种存储器，但是速度比内存高得多）- 控制，主要是对计算机其他部件进行控制，比如对显示器、喇叭进行控制</code></pre><p>内存和硬盘 主要提供 cpu 运算和控制时所使用的数据</p><ul><li>内存是一种高速存储器，但不能持久存储数据，断电数据就丢失</li><li>硬盘是一种低速存储器，可以持久存储数据</li><li>cpu 进行数据处理的时候，先判断内存里面是否有该数据，如果有直接读取处理，把处理结果存储在内存中；如果没有一般都是控制 dma 把数据存储到内存中，然后从内存中读取数据</li></ul><a id="more"></a><h2 id="1-2认识Python"><a href="#1-2认识Python" class="headerlink" title="1.2认识Python"></a>1.2认识Python</h2><p>Python 定义：Python 是一门计算机编程语言</p><p>Python 优点：简单易学、免费开源、应用广泛（自动化测试、自动化运维、web开发、爬虫、数据分析、机器学习）</p><p>Python 基础学习路径：python入门 -&gt; 流程控制 -&gt; 数据序列 -&gt; 函数 -&gt; 文件操作 -&gt; 面向对象 -&gt; 模块包异常</p><h2 id="1-3第一个Python程序"><a href="#1-3第一个Python程序" class="headerlink" title="1.3第一个Python程序"></a>1.3第一个Python程序</h2><p>python解释器的作用和分类</p><ul><li>python 解释器是解释和执行 python 代码的程序</li><li>python 解释器有，CPython、IPython、PyPy、Jython、IronPython</li></ul><p>Python解释器的下载和安装</p><p>Pycharm的作用</p><p>下载和安装Pycharm</p><p>Pycharm的基本使用：新建项目、写代码、运行代码</p><p>Pycharm的基本设置：外观的设置、解释器的设置、项目管理(新建、打开、关闭)</p><h2 id="1-4注释"><a href="#1-4注释" class="headerlink" title="1.4注释"></a>1.4注释</h2><p>注释的作用</p><p>注释的分类(单行、块注释、文档字符串)</p><h2 id="1-5变量标识符关键字"><a href="#1-5变量标识符关键字" class="headerlink" title="1.5变量标识符关键字"></a>1.5变量标识符关键字</h2><p>变量的作用和存储原理：存储数据的内存地址的名字</p><p>定义变量</p><p>使用变量</p><h2 id="1-6输入和输出"><a href="#1-6输入和输出" class="headerlink" title="1.6输入和输出"></a>1.6输入和输出</h2><h2 id="1-7数据类型转换"><a href="#1-7数据类型转换" class="headerlink" title="1.7数据类型转换"></a>1.7数据类型转换</h2><h2 id="1-8运算符"><a href="#1-8运算符" class="headerlink" title="1.8运算符"></a>1.8运算符</h2><h1 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2.流程控制"></a>2.流程控制</h1><h1 id="3-数据序列"><a href="#3-数据序列" class="headerlink" title="3.数据序列"></a>3.数据序列</h1><h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h1><h1 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5.文件操作"></a>5.文件操作</h1><h1 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6.面向对象"></a>6.面向对象</h1><h1 id="7-模块包异常"><a href="#7-模块包异常" class="headerlink" title="7.模块包异常"></a>7.模块包异常</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Python基础入门&quot;&gt;&lt;a href=&quot;#1-Python基础入门&quot; class=&quot;headerlink&quot; title=&quot;1.Python基础入门&quot;&gt;&lt;/a&gt;1.Python基础入门&lt;/h1&gt;&lt;h2 id=&quot;1-1计算机组成&quot;&gt;&lt;a href=&quot;#1-1计算机组成&quot; class=&quot;headerlink&quot; title=&quot;1.1计算机组成&quot;&gt;&lt;/a&gt;1.1计算机组成&lt;/h2&gt;&lt;p&gt;cpu 主要是用来进行运算和控制的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 运算，主要是算术运算（+、-、*、\）、比较运算（&amp;gt;、&amp;lt;、=、&amp;gt;=、&amp;lt;=）和逻辑运算（与或非），cpu所有运算使用的数据都来自于cpu内部的存储器（也叫寄存器，它和内存差不多也是一种存储器，但是速度比内存高得多）
- 控制，主要是对计算机其他部件进行控制，比如对显示器、喇叭进行控制
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内存和硬盘 主要提供 cpu 运算和控制时所使用的数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存是一种高速存储器，但不能持久存储数据，断电数据就丢失&lt;/li&gt;
&lt;li&gt;硬盘是一种低速存储器，可以持久存储数据&lt;/li&gt;
&lt;li&gt;cpu 进行数据处理的时候，先判断内存里面是否有该数据，如果有直接读取处理，把处理结果存储在内存中；如果没有一般都是控制 dma 把数据存储到内存中，然后从内存中读取数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="python" scheme="http://jihuawisdom.cn/tags/python/"/>
    
      <category term="基础语法" scheme="http://jihuawisdom.cn/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pythonic代码n例</title>
    <link href="http://jihuawisdom.cn/2019/07/16/Pythonic%E4%BB%A3%E7%A0%81n%E4%BE%8B/"/>
    <id>http://jihuawisdom.cn/2019/07/16/Pythonic代码n例/</id>
    <published>2019-07-16T13:50:40.000Z</published>
    <updated>2019-11-25T09:31:42.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两个变量交换"><a href="#1-两个变量交换" class="headerlink" title="1.两个变量交换"></a>1.两个变量交换</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure><p>python 的 packaging/unpackaging 机制</p><h1 id="2-遍历容器类数据"><a href="#2-遍历容器类数据" class="headerlink" title="2.遍历容器类数据"></a>2.遍历容器类数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> alist:</span><br><span class="line">  do_sth_with(item)</span><br></pre></td></tr></table></figure><p>和 java 里面的 for…each 类似</p><a id="more"></a><h1 id="3-关闭资源"><a href="#3-关闭资源" class="headerlink" title="3.关闭资源"></a>3.关闭资源</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">  do_sth_with(f)</span><br></pre></td></tr></table></figure><p>Python 里面的上下文管理器可以自动关闭资源</p><p>4.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-两个变量交换&quot;&gt;&lt;a href=&quot;#1-两个变量交换&quot; class=&quot;headerlink&quot; title=&quot;1.两个变量交换&quot;&gt;&lt;/a&gt;1.两个变量交换&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a, b = b, a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;python 的 packaging/unpackaging 机制&lt;/p&gt;
&lt;h1 id=&quot;2-遍历容器类数据&quot;&gt;&lt;a href=&quot;#2-遍历容器类数据&quot; class=&quot;headerlink&quot; title=&quot;2.遍历容器类数据&quot;&gt;&lt;/a&gt;2.遍历容器类数据&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; alist:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  do_sth_with(item)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;和 java 里面的 for…each 类似&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="Pythonic" scheme="http://jihuawisdom.cn/tags/Pythonic/"/>
    
      <category term="Python特有语法" scheme="http://jihuawisdom.cn/tags/Python%E7%89%B9%E6%9C%89%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Python特色" scheme="http://jihuawisdom.cn/tags/Python%E7%89%B9%E8%89%B2/"/>
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(9)-程序设计建议</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-9-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%BB%BA%E8%AE%AE/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-9-程序设计建议/</id>
    <published>2019-07-11T15:14:15.000Z</published>
    <updated>2019-07-11T15:33:29.196Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第9小节，其他小节可以通过下面链接阅读。</p><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.程序设计建议</p><a id="more"></a><h2 id="程序设计建议"><a href="#程序设计建议" class="headerlink" title="程序设计建议"></a>程序设计建议</h2><ul><li>代码应该以不影响Python的其他实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。</li></ul><p>例如，不要依赖CPython为字符串连接 a + = b 或 a = a + b 形式的语句的高效实现。即使在CPython中，这种优化也很脆弱（它只适用于某些类型），并且在不使用引用计数的实现中根本不存在。在库的性能敏感部分，应该使用’.join（）形式。这将确保在各种实现中以线性时间进行连接。</p><ul><li><p>像None这样的单例的比较应该总是使用 is 或者 is not，而不是相等的运算符。</p><p>另外，当你想要表达 <code>if x is not None</code>时，要避免写为<code>if x</code> ，因为在测试默认为None的变量或参数是否设置为其他值时，另一个值可能也具有在布尔上下文中为 false 的类型（例如容器）。</p></li><li><p>使用<code>is not</code>操作符而不是<code>not...is...</code>。虽然这两个表达式的功能相同，前者具有更好的可读性并且更受喜欢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐写法</span></span><br><span class="line"><span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> foo <span class="keyword">is</span> <span class="keyword">None</span>:</span><br></pre></td></tr></table></figure></li><li><p>在使用丰富的比较实现排序操作时，最好实现所有六个操作 (__ne__，__lt__，__le__，__gt__，__ge__）而不是依靠其它代码只能进行一个特定的比较。</p><p>为了减少所涉及的工作量，functools.total_ordering()装饰器提供了一个工具来生成缺失的比较函数。</p><p>PEP 207表明，Python假定自反性规则。因此，编译器可以交换y &gt; x和x &lt; y，y &gt;= x和x &lt;= y，也可以交换参数x == y和x != y。sort() 和min() )操作保证使用 &lt; 运算符，而max() 函数使用 &gt; 运算符。不管怎样，最好实现所有六个操作，避免在其它情况下产生混淆。</p></li><li><p>使用def语句，而不是使用赋值语句将lambda表达式绑定到标识符上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐写法</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">2</span>*x</span><br></pre></td></tr></table></figure></li></ul><p>  第一种形式意味着所得的函数对象的名称是‘f’而不是一般的‘<lambda>’。这在回溯和字符串表示中更有用。赋值语句的使用消除了lambda表达式可以提供显示def声明的唯一好处（例如它可以嵌在更大的表达式里面）。</lambda></p><ul><li><p>从Exception而不是BaseException中派生出异常。直接继承BaseException是保留给那些捕捉几乎总是错的异常的。</p><p>基于可能需要捕获异常的代码的区别，来设计异常层次结构，而不是引发异常的位置。旨在以编程方式回答“出了什么问题？”的问题，而不是只说“问题产生了”（有关内置异常层次结构的本课程示例，请参阅PEP 3151）</p><p>类的命名规则适用于此，只是当异常确实是错误的时候，需要在异常类名添加“Error”后缀。非本地的流控制或其他形式的信号使用非错误的异常，不需要特殊的后缀。</p></li><li><p>适当使用异常链。Python3中，“raise X from Y”用来表明明确的更换而不失去原来追踪到的信息。 </p><p>当故意替换一个内部异常（Python 2中使用“raise X”而Python 3.3+中使用“raise X from None”），确保相关的细节被转移到新的异常中（比如当转换KeyError为AttributeError时保留属性名，或在新的异常消息中嵌入原始异常的文本）。</p></li><li><p>Python 3中产生异常，使用raise ValueError(‘message’)替换python 2中的形式raise ValueError,’message’。</p><p>后一种形式是不合法的Python 3语法。</p><p>多亏了使用小括号的形式，当异常的参数很长或包含格式化字符传时，不必再使用续行符。</p></li><li><p>捕获异常时，尽可能提及特定的异常，而不是使用空的except：子句。<br>例如，使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> platform_specific_module</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    platform_specific_module = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></li></ul><p>  空的except：子句将捕获SystemExit和KeyboardInterrupt异常，这使得很难用Control-C来中断程序，也会掩饰其它的问题。如果想捕获会导致程序错误的所有异常，使用except Exception:（空异常相当于except BaseException:）<br>  一条好的经验法则是将使用空‘except’子句限制为下面两种情况：</p><ol><li>如果异常处理程序将打印出来或记录日志跟踪；至少用户能够意识到有错误发生。</li><li>如果代码需要做一些清理工作，但是随后让异常用 raise 抛出。处理这种情况用 try…finally 更好。</li></ol><ul><li><p>当用一个名字绑定捕获异常时，更喜欢Python2.6中添加的明确的名称绑定语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    process_data()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">    <span class="keyword">raise</span> DataProcessingFailedError(str(exc))</span><br></pre></td></tr></table></figure></li></ul><p>  这是Python3中唯一支持的语法，可以避免旧的基于逗号的语法的歧义问题。</p><ul><li><p>捕获操作系统错误时，我更喜欢 Python 3.3 中引入的显式异常层次结构，而不是内省errno值。</p></li><li><p>此外，对于所有try / except子句，将try子句限制为所需的绝对最小代码量。同样，这可以避免掩盖错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐的做法</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    value = collection[key]</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="keyword">return</span> key_not_found(key)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> handle_value(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的做法</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Too broad!</span></span><br><span class="line">    <span class="keyword">return</span> handle_value(collection[key])</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="comment"># Will also catch KeyError raised by handle_value()</span></span><br><span class="line">    <span class="keyword">return</span> key_not_found(key)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当资源是特定代码段的本地资源时，请使用with语句以确保在使用后立即可靠地清除它。 try / finally语句也是可以接受的。</p></li><li><p>当除了获取和释放资源之外，还需要做其他一些事情的时候，应该通过单独的函数或方法调用上下文管理器。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐的做法</span></span><br><span class="line"><span class="keyword">with</span> conn.begin_transaction():</span><br><span class="line">    do_stuff_in_transaction(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的做法</span></span><br><span class="line"><span class="keyword">with</span> conn:</span><br><span class="line">    do_stuff_in_transaction(conn)</span><br></pre></td></tr></table></figure><p>后者的例子没有提供任何信息表明 __enter__ 和 __exit__ 方法做了除了事务结束后关闭连接以外的其他什么事情。 在这种情况下，显式表达是很重要的。</p></li><li><p>返回语句保持一致。函数中的所有返回语句都有返回值，或都没有返回值。如果任意一个返回语句有返回值，那么任意没有返回值的返回语句应该明确指出return None，并且应该有显示的返回语句放在函数结尾（如果可以）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐的做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(x)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用字符串方法代替string模块。</p><p>字符串方法总是更快并且与unicode字符串使用相同的API。如果必须向后兼容Python2.0以前的版本，可以无视这个原则。</p></li><li><p>使用<code>&#39;&#39;.startswith()</code>和<code>&#39;&#39;.endswith()</code>代替字符串切片来检查前缀和后缀。</p><p>startswith()和endswith()更清晰，更不容易出错。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> foo.startswith(<span class="string">'bar'</span>):</span><br><span class="line">No:  <span class="keyword">if</span> foo[:<span class="number">3</span>] == <span class="string">'bar'</span>:</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>对象类型的比较使用isinstance()代替直接比较类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> isinstance(obj, int):</span><br><span class="line">No:  <span class="keyword">if</span> type(obj) <span class="keyword">is</span> type(<span class="number">1</span>):</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当检查一个对象是否是字符串时，牢记它也可能是一个 unicode 字符串！Python 2中，str和unicode有共同的基类 basestring，所以你可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isinstance(obj, basestring):</span><br></pre></td></tr></table></figure><p>注意，Python3 中， unicode 和 basestring 不再存在（只有str），并且bytes对象不再是 string（而是一个integers序列）</p></li><li><p>对于序列（字符串，列表，元组），要充分利用空序列就是 false 的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> <span class="keyword">not</span> seq:</span><br><span class="line">     <span class="keyword">if</span> seq:</span><br><span class="line"></span><br><span class="line">No:  <span class="keyword">if</span> len(seq):</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> len(seq):</span><br></pre></td></tr></table></figure></li><li><p>不要书写依赖后置空格的字符串。这些后置空格在视觉上无法区分，并且有些编辑器（或最近 reindent.py）将去掉他们。</p></li><li><p>不要用 == 将布尔值与True或False进行比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes:   <span class="keyword">if</span> greeting:</span><br><span class="line">No:    <span class="keyword">if</span> greeting == <span class="keyword">True</span>:</span><br><span class="line">Worse: <span class="keyword">if</span> greeting <span class="keyword">is</span> <span class="keyword">True</span>:</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><p>随着PEP 484的发布，函数注释的样式规则也发生了如下的变化：</p><ul><li><p>为了向前兼容，Python 3代码中的函数注释应该优选使用PEP 484语法。 （上一节中有一些注释的格式的建议。）</p></li><li><p>不再鼓励使用先前在本PEP中推荐的注释样式。</p></li><li><p>但是，除stdlib外，现在鼓励在PEP 484规则内进行实践。例如，使用PEP 484样式类型的注释标记大型第三方库或应用程序，查看添加这些注释的容易程度，并观察它们的存在是否增加了代码可理解性。</p></li><li><p>Python标准库应该保守采用这样的注释，除非用于它们的新代码和大型重构。</p></li><li><p>对于想要使用不同的函数注释的代码，建议在PEP检查表单中对类型检查进行如下注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type: ignore</span></span><br></pre></td></tr></table></figure><p>靠近文件顶部；这告诉类型检查器忽略所有注释。 （在PEP 484中可以找到更细粒度的禁用类型检查器的方法。）</p></li><li><p>像 linters、类型检查器都是可选的、单独的工具。默认情况下，Python解释器不应由于类型检查而发出任何消息，并且不应基于注释更改其行为。</p></li><li><p>不想使用类型检查器的用户可以自由地忽略它们。但是，一般第三方库包的用户可能希望在这些包上运行类型检查程序。为此，PEP 484建议使用存根文件：.pyi文件，检查类型的时候，类型检查程序读取 .pyi文件，而不是相应的.py文件。存根文件可以与库一起分发，也可以通过类型化仓库（与库作者的许可）单独分发。</p></li><li><p>对于需要向后兼容的代码，可以以注释的形式添加类型注释。参见PEP 484 [6]的相关章节</p></li></ul><h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><p>PEP 526引入了变量注释。它们的样式建议类似于上面描述的功能注释。</p><ul><li><p>模块级变量，类和实例变量以及局部变量的注释在冒号后应该有一个空格（特质类型提示中的类型注释）</p></li><li><p>冒号前应该没有空格</p></li><li><p>如果变量右侧有赋值，在等号两侧应该各有一个空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐的做法</span></span><br><span class="line">code: int</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    coords: Tuple[int, int]</span><br><span class="line">    label: str = <span class="string">'&lt;unknown&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的做法</span></span><br><span class="line">code:int  <span class="comment"># No space after colon</span></span><br><span class="line">code : int  <span class="comment"># Space before colon</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    result: int=<span class="number">0</span>  <span class="comment"># No spaces around equality sign</span></span><br></pre></td></tr></table></figure></li><li><p>尽管PEP 526 从 Python 3.6 开始被接受，但变量注释语法是所有 Python 版本的存根文件的首选语法（有关详细信息，请参阅PEP 484）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第9小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/07/11/python代码样式指南-1-2&quot;&gt;1.介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/07/11/python代码样式指南-1-2&quot;&gt;2.本指南不适用的情况&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/07/11/python代码样式指南-3-代码布局/&quot;&gt;3.代码布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;/2019/07/11/python代码样式指南-4-字符串引号/&quot;&gt;字符串引号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;/2019/07/11/python代码样式指南-5-表达式和语句中的空格/&quot;&gt;表达式和语句中的空格&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.&lt;a href=&quot;/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/&quot;&gt;什么时候使用尾部逗号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7.&lt;a href=&quot;/2019/07/11/python代码样式指南-7-注释/&quot;&gt;注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8.&lt;a href=&quot;/2019/07/11/python代码样式指南-8-命名规范/&quot;&gt;命名规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9.程序设计建议&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="类型注释" scheme="http://jihuawisdom.cn/tags/%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(8)-命名规范</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-8-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-8-命名规范/</id>
    <published>2019-07-11T15:13:53.000Z</published>
    <updated>2019-07-13T14:26:21.779Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第8小节，其他小节可以通过下面链接阅读。</p><a id="more"></a><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.命名规范</p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><p>Python库的命名规范有点儿混乱，所以我们不会将他们变得完全一致，不过，本文是目前推荐的命名标准，新的模块和包（包括第三方框架）应该按这些标准书写，但对有不同的风格的已有的库，保持内部一致性是首选。</p><h1 id="根本原则"><a href="#根本原则" class="headerlink" title="根本原则"></a>根本原则</h1><p>对于用户可见的API，它们的公开部分的名称，应该根据约定的用法来命名，而不是根据实现来命名。</p><h1 id="描述性：命名风格"><a href="#描述性：命名风格" class="headerlink" title="描述性：命名风格"></a>描述性：命名风格</h1><p>编程界有很多不同的命名风格。下面列表有助于识别使用了什么样的命名风格，这与他们的作用无关。</p><p>下面这些是最常见的命名风格：</p><ul><li><p>b（单个小写字母）</p></li><li><p>B（单个大写字母）</p></li><li><p>小写字符串</p></li><li><p>lower_case_with_underscores 带下划线的小写字符串</p></li><li><p>大写字符串</p></li><li><p>UPPER_CASE_WITH_UNDERSCORES 带下划线的大写字符串</p></li><li><p>CapitalizedWords 单词首字母大写的字符串（或 CapWords，或 CamelCase——因其字母看起来高低不平而得名[3]）。这有时也被称为StudlyCaps。</p><p>注意：当 CapWords 中使用了缩写，大写所有的缩写字母。因此HTTPServerError优于HttpServerError。</p></li><li><p>mixedCase 混用大小写的字符串（首个单词的首字母以小写字母开头）</p></li><li><p>Capitalized_Words_With_Underscores 带下划线的首字母大写字符串（令人厌恶的！）</p></li></ul><p>还有一种风格，使用简短独特的前缀与相关的名字组织在一起。Python中很少这样用，提一下是为了文档的完整性。例如，os.stat()函数返回一个元祖，它的元素名字通常类似st_mode，st_size，st_mtime等等这样。（这样做是为了强调与POSIX系统中调用的结构体的对应关系，这对熟悉这些的程序员有帮助。）</p><p>X11库的所有的公开函数以X开头。Python中，这种风格通常认为是不必要的，因为属性名和方法名以对象名作前缀，而函数名以模块名作前缀。</p><p>另外，以下特殊形式，公认有前置或后置下划线（一般可以与任何约定相结合）：</p><ul><li><p>_single_leading_underscore 单前置下划线：弱“内部使用”标志。例如 from M import *不会导入以下划线开头的对象。</p></li><li><p>single_trailing_underscore_ 单后置下划线：按惯例避免与Python关键字冲突时使用，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tkinter.Toplevel(master, class_=<span class="string">'ClassName'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>__double_leading_underscore 双前置下划线：强“内部使用”标志。当命名类属性时，调用时的名称会被修改（类FooBar中，__boo 会变成 _FooBar__boo；见下文）。</p></li><li><p>__double_leading_and_trailing_underscore__ 前后都是双下划线：存在于用户控制的命名空间中的“魔法”的对象或属性。</p><p>例如：__init__，__import__ 或 __file__，除了在文档中使用他们，不要创造这样的名字。</p></li></ul><h1 id="规定性：命名约定"><a href="#规定性：命名约定" class="headerlink" title="规定性：命名约定"></a>规定性：命名约定</h1><h2 id="避免采用的名字"><a href="#避免采用的名字" class="headerlink" title="避免采用的名字"></a>避免采用的名字</h2><p>不要使用字符‘l’（小写字母el），‘O’（大写字母oh）或‘I’（大写字母eye）作为单字符变量名。</p><p>在某些字体中，这些字符与数字1和0是没有区别的。当想使用‘l’时，用‘L’代替。</p><h2 id="ASCII兼容性"><a href="#ASCII兼容性" class="headerlink" title="ASCII兼容性"></a>ASCII兼容性</h2><p>标准库中使用的标识符必须与ASCII兼容，如PEP 3131的策略部分所描述。</p><h2 id="包名和模块名"><a href="#包名和模块名" class="headerlink" title="包名和模块名"></a>包名和模块名</h2><p><strong>模块</strong>应具有简短的<strong>全小写名称</strong>。可以在模块名中<strong>使用下划线</strong>来提高可读性。</p><p>Python <strong>包</strong>也应该有简短的<strong>全小写名称</strong>，但<strong>不鼓励使用下划线</strong>。</p><p>当一个用 C 或 C++ 编写的扩展模块，伴随有用 Python 模块来提供了一个更高层次（例如更面向对象）的接口时，C/C++ 模块名有一个前导下划线（如 _socket）。</p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p><strong>类名</strong>通常使用<strong>单词首字母大写的 CapWords（驼峰）规则</strong>。</p><p>在接口被记录并主要用作可调用的情况下，可以使用函数的命名约定。</p><p>请注意，内置名称有一个单独的约定：大多数内置名称是单个单词（或两个单词一起运行），CapWords 约定仅用于异常名称和内置常量。</p><h2 id="类型变量的名称"><a href="#类型变量的名称" class="headerlink" title="类型变量的名称"></a>类型变量的名称</h2><p><strong>类型变量</strong>的名称应该使用<strong>单词首字母大写的 CapWords（驼峰）规则</strong>，并且尽量短，比如：T, AnyStr, Num。对于协变量和有协变行为的变量，建议添加后缀 __co 或者 __contra。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">VT_co = TypeVar(<span class="string">'VT_co'</span>, covariant=<span class="keyword">True</span>)</span><br><span class="line">KT_contra = TypeVar(<span class="string">'KT_contra'</span>, contravariant=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="异常名"><a href="#异常名" class="headerlink" title="异常名"></a>异常名</h2><p>因为<strong>异常</strong>应该是类，所以异常的命名和类的命名规则一样，<strong>使用单词首字母大写的 CapWords（驼峰）规则</strong>。不过，如果这个异常确实是一个<strong>错误</strong>，异常名应该使用<strong>后缀“Error”</strong>。</p><h2 id="全局变量名"><a href="#全局变量名" class="headerlink" title="全局变量名"></a>全局变量名</h2><p>（希望这些变量是在一个模块内使用。）<strong>全局变量名</strong>命名约定和函数的命名约定相同，应该是<strong>小写字母，必要时单词之间用下划线分开</strong>。</p><p>模块设计为通过from M import *来使用，应使用 __all__ 机制防止导出全局变量，或使用加前缀的旧规则，为全局变量加<strong>前置单下划线</strong>，来表明这些全局变量是“非公开模块”。</p><h2 id="函数和变量名"><a href="#函数和变量名" class="headerlink" title="函数和变量名"></a>函数和变量名</h2><p><strong>函数名</strong>应该是<strong>小写字母，必要时单词之间用下划线分开</strong>，以提高可读性。</p><p><strong>变量名</strong>称遵循与函数名称相同的约定。</p><p>混合大小写只被允许用在这种风格已经占主导地位的上下文中（例如threading.py），以保持向后兼容性。</p><h2 id="函数和方法参数"><a href="#函数和方法参数" class="headerlink" title="函数和方法参数"></a>函数和方法参数</h2><p>参数名和变量名遵循相同的约定，<strong>小写字母，必要时单词之间用下划线分开</strong>，以提高可读性。</p><p>使用 <strong>self 为实例化方法的第一个参数</strong>。</p><p>使用 <strong>cls 为类方法的第一个参数</strong>。</p><p>如果函数的参数名<strong>与保留关键字冲突，最好是为参数名添加单个后置下划线</strong>，而不是使用缩写或拼写错误。</p><p>因此class_ 比clss好。（也许使用同义词来避免更好。）。</p><h2 id="类的方法名和实例变量"><a href="#类的方法名和实例变量" class="headerlink" title="类的方法名和实例变量"></a>类的方法名和实例变量</h2><p>采用函数命名规则：<strong>全部使用小写字母，必要时单词之间用下划线分开</strong>，以提高可读性。</p><p>只对非公开的方法和实例变量使用一个前置下划线。</p><p>为了避免和子类命名冲突，使用两个前置下划线，来调用 Python 的名称修改规则。</p><p>Python用类名修改这些名字：如果类 Foo 有一个属性名为__a，通过 Foo.__a 不能访问，需要调用Foo._Foo__a来访问。通常，<strong>两个前置下划线只用来避免与子类的属性名冲突</strong>。</p><p>注意：关于__names 的使用存在一些争论（见下文）。</p><p><strong>变量、函数、全局变量、函数和方法参数、方法、实例变量</strong> 的命名规则都相同，<strong>全部使用小写字母，必要时单词之间用下划线分开</strong>。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>常量</strong>通常定义于模块级别，并且<strong>所有的字母都是大写，单词用下划线分开</strong>。例如MAX_OVERFLOW和TOTAL。</p><h2 id="继承的设计"><a href="#继承的设计" class="headerlink" title="继承的设计"></a>继承的设计</h2><p>设计类的时候，务必要确定类的方法和实例变量（统称为：“属性”）是否公开，如果有疑问，那就选择非公开，因为以后把其变成公开比把一个公开属性改成非公开要容易。</p><p>public 属性是指你希望与你的类不相关的客户端使用的属性，您承诺不会做向后不兼容的更改。非公开属性是指不打算由第三方使用的属性;您不能保证非公共属性不会更改甚至不会被删除。</p><p>在这里没有使用术语 “private”，因为 Python 中没有真正私有的属性（python 中没有通常不必要的工作）。</p><p>另一类属性是属于“子类 API”的属性（通常在其他语言中称为 “protected”）。某些类被设计为基类，要么扩展，要么修改类的某些方面的行为。在设计这样的类的时候，要明确确定哪些属性是公开的，哪些属性是子类 API 的一部分，哪些属性是真正只在你的基类中使用。</p><p>出于这种考虑，下面有一份 Python 特色的指南：</p><ul><li>公开属性应该没有前置下划线。</li><li><p>如果公开属性名和保留关键字冲突，给属性名添加一个后置下划线。这比缩写或错误拼写更可取。（然而，尽管有这样的规定，对于任何类的变量或参数，特别是类方法的第一个参数，‘cls’是首选的拼写方式）</p><pre><code>注1：参见上面对类方法的参数名的建议。</code></pre></li><li><p>对于简单的公开数据属性，最好只暴露属性名，而不是使用复杂的访问器/修改器(getter/setter)方法。记住，Python 为未来增强提供了一条简单的途径，你应该发现 python 中，使用简单的数据属性也可以增加需要的功能行为。在这种情况下，使用属性来隐藏简单数据属性访问语法后面的功能实现是最好的方法。</p><pre><code>注1：属性仅工作于新风格的类。注2：尽量保持功能行为无副作用，尽管如缓存等副作用通常是好的。注3：计算开销较大的操作避免使用属性，属性表示法使调用者相信访问（相对）是廉价的。</code></pre></li><li><p>如果确定你的类会被子类化，并有不希望子类使用的属性，考虑用两个前置下划线无后置下划线来命名它们。这将调用Python的名称修改算法，类名将被添加为属性名的一部分。当子类不无意间包括相同的属性名时，这有助于帮助避免属性名冲突。</p><pre><code>注1：注意如果修改名称仅用于简单类名，一个子类使用相同的类名和属性名，仍然会有名字冲突。注2：名称修改会带来一定的不便，如调试和 \_\_getattr\_\_()。然而，名称修改算法有良好的文档，也容易手工执行。注3：不是每个人都喜欢名称修改。尽量平衡避免意外的名称冲突和高级调用者的可能。</code></pre></li></ul><h2 id="公共和内部接口"><a href="#公共和内部接口" class="headerlink" title="公共和内部接口"></a>公共和内部接口</h2><p>任何向后兼容性保证，只适用于公共接口。因此，重要的是用户能够清楚地区分公开和内部接口。</p><p>文档接口被认为是公开的，除非文档明确声明他们是临时接口或内部接口，免除通常的向后兼容保证。所有非文档化的接口应假定为内部接口。</p><p>为了更好的支持自省，模块应该使用 __all__ 属性显示声明他们公开 API 的名字， __all__ 设置为一个空列表表示该模块没有公开 API。<br>即使 __all__ 设置的适当，<strong>内部接口（包，模块，类，函数，属性或者其它名字）仍应以一个前置下划线作前缀</strong>。</p><p>如果一个接口包含任何命名空间（包，模块，或类）都是内部的，那么这个接口被认为是内部接口。</p><p>导入名称也被认为是实现细节。其他模块不能依赖于对这些导入名称的间接访问，除非它们包含了模块的 API 的显式记录部分，例如 os.path 或从子模块公开功能的包的 __init__ 模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第8小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="命名规范" scheme="http://jihuawisdom.cn/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="类名" scheme="http://jihuawisdom.cn/tags/%E7%B1%BB%E5%90%8D/"/>
    
      <category term="变量名" scheme="http://jihuawisdom.cn/tags/%E5%8F%98%E9%87%8F%E5%90%8D/"/>
    
      <category term="函数名" scheme="http://jihuawisdom.cn/tags/%E5%87%BD%E6%95%B0%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(7)-注释</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-7-%E6%B3%A8%E9%87%8A/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-7-注释/</id>
    <published>2019-07-11T15:13:34.000Z</published>
    <updated>2019-07-13T07:09:46.048Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第7小节，其他小节可以通过下面链接阅读。</p><a id="more"></a><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.注释</p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>与代码相矛盾的注释比没有注释更糟糕。当代码修改时，始终优先更新注释！</p><p>注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符。</p><p>如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。</p><p>除了最后一句之外，应该在多句注释中句尾的句号后边使用两个空格。</p><p>写英语注释时，遵循Strunk and White风格的英语写作规范。</p><p>非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。</p><h1 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h1><p>注释块通常适用于一些（或全部）紧跟其后的代码，并且与这些代码使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非是注释里面的文本有缩进）。</p><p>注释块内的段落之间由仅包含#的行隔开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Some platforms don't support lchmod().  Often the function exists</span></span><br><span class="line"><span class="comment"># anyway, as a stub that always returns ENOSUP or perhaps EOPNOTSUPP.</span></span><br><span class="line"><span class="comment"># (No, I don't know why that's a good design.)  ./configure will detect</span></span><br><span class="line"><span class="comment"># this and reject it--so HAVE_LCHMOD still won't be defined on such</span></span><br><span class="line"><span class="comment"># platforms.  This is Very Helpful.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, sometimes platforms without a working lchmod() *do* have</span></span><br><span class="line"><span class="comment"># fchmodat().  (Examples: Linux kernel 3.2 with glibc 2.15,</span></span><br><span class="line"><span class="comment"># OpenIndiana 3.x.)  And fchmodat() has a flag that theoretically makes</span></span><br><span class="line"><span class="comment"># it behave like lchmod().</span></span><br></pre></td></tr></table></figure><h1 id="行内注释"><a href="#行内注释" class="headerlink" title="行内注释"></a>行内注释</h1><p>谨慎地使用行内注释。</p><p>行内注释就是和代码在同一行上的注释，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。</p><p>如果行内注释表达的意思显而易见，那么它就是不必要的。 </p><p>不要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span>                 <span class="comment"># Increment x</span></span><br></pre></td></tr></table></figure><p>但有时，这样是有用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span>                 <span class="comment"># Compensate for border</span></span><br></pre></td></tr></table></figure><h1 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h1><p>编写好的文档字符串约定在PEP 257中。</p><ul><li><p>所有公共模块、函数、类和方法都要求必须编写文档字符串。对非公共的方法不要求必须写文档字符串，但应该写个注释描述这个方法是做什么的。这些注释应该写在def行后面。</p></li><li><p>PEP 257描述了好的文档字符串规范。最重要的是，多行文档字符串以一行”””结束，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Return a foobang</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optional plotz says to frobnicate the bizbaz first.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li><li><p>对于只有一行的文档字符串，关闭”””在同一行上。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第7小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="注释" scheme="http://jihuawisdom.cn/tags/%E6%B3%A8%E9%87%8A/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(6)-什么时候使用尾部逗号</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B0%BE%E9%83%A8%E9%80%97%E5%8F%B7/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/</id>
    <published>2019-07-11T15:13:15.000Z</published>
    <updated>2019-07-12T12:01:19.718Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第6小节，其他小节可以通过下面链接阅读。</p><a id="more"></a><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.什么时候使用尾部逗号</p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><h1 id="什么时候使用尾部逗号"><a href="#什么时候使用尾部逗号" class="headerlink" title="什么时候使用尾部逗号"></a>什么时候使用尾部逗号</h1><p>尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line">FILES = (<span class="string">'setup.cfg'</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line">FILES = <span class="string">'setup.cfg'</span>,</span><br></pre></td></tr></table></figure><p>当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。通常的用法是（比如列表）<strong>每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line">FILES = [</span><br><span class="line">    <span class="string">'setup.cfg'</span>,</span><br><span class="line">    <span class="string">'tox.ini'</span>,</span><br><span class="line">    ]</span><br><span class="line">initialize(FILES,</span><br><span class="line">           error=<span class="keyword">True</span>,</span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line">FILES = [<span class="string">'setup.cfg'</span>, <span class="string">'tox.ini'</span>,]</span><br><span class="line">initialize(FILES, error=<span class="keyword">True</span>,)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第6小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="逗号" scheme="http://jihuawisdom.cn/tags/%E9%80%97%E5%8F%B7/"/>
    
      <category term="尾部逗号" scheme="http://jihuawisdom.cn/tags/%E5%B0%BE%E9%83%A8%E9%80%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(5)-表达式和语句中的空格</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-5-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-5-表达式和语句中的空格/</id>
    <published>2019-07-11T15:06:21.000Z</published>
    <updated>2019-07-12T11:57:56.471Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第5小节，其他小节可以通过下面链接阅读。</p><a id="more"></a><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.表达式和语句中的空格</p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><h1 id="多余的空格"><a href="#多余的空格" class="headerlink" title="多余的空格"></a>多余的空格</h1><p>避免以下情况使用多余的空格：</p><ul><li><p>紧挨着小括号，中括号或大括号不需要空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;)</span><br><span class="line">No:  spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125; )</span><br></pre></td></tr></table></figure></li><li><p>尾逗号和右括号之间不需要空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: foo = (<span class="number">0</span>,)</span><br><span class="line">No:  bar = (<span class="number">0</span>, )</span><br></pre></td></tr></table></figure></li><li><p>在逗号、分号或冒号前不需要空格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> x == <span class="number">4</span>: <span class="keyword">print</span> x, y; x, y = y, x</span><br><span class="line">No:  <span class="keyword">if</span> x == <span class="number">4</span> : <span class="keyword">print</span> x , y ; x , y = y , x</span><br></pre></td></tr></table></figure><p>在切片中冒号是一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符，<strong>pycharm默认切片冒号两侧都不保留空格</strong>）。在一个扩展切片中，两个冒号必须有相等数量的空格。例外：当一个切片参数被省略时，该空格被省略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line">ham[<span class="number">1</span>:<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>], ham[:<span class="number">9</span>:<span class="number">3</span>], ham[<span class="number">1</span>::<span class="number">3</span>], ham[<span class="number">1</span>:<span class="number">9</span>:]</span><br><span class="line">ham[lower:upper], ham[lower:upper:], ham[lower::step]</span><br><span class="line">ham[lower+offset : upper+offset]</span><br><span class="line">ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]</span><br><span class="line">ham[lower + offset : upper + offset]</span><br><span class="line"></span><br><span class="line"><span class="comment">#不推荐做法</span></span><br><span class="line">ham[lower + offset:upper + offset]</span><br><span class="line">ham[<span class="number">1</span>: <span class="number">9</span>], ham[<span class="number">1</span> :<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span> :<span class="number">3</span>]</span><br><span class="line">ham[lower : : upper]</span><br><span class="line">ham[ : upper]</span><br></pre></td></tr></table></figure></li><li><p>函数调用的参数列表的开始处<strong>左括号之前</strong>不需要空格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: spam(<span class="number">1</span>)</span><br><span class="line">No:  spam (<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>索引或切片开始的<strong>左括号之前</strong>不需要空格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: dct[<span class="string">'key'</span>] = lst[index]</span><br><span class="line">No:  dct [<span class="string">'key'</span>] = lst [index]</span><br></pre></td></tr></table></figure></li><li><p>为了与另外的赋值（或其它）操作符对齐，分配不止一个空格，<strong>不建议对赋值操作符对齐</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">long_variable = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line">x             = <span class="number">1</span></span><br><span class="line">y             = <span class="number">2</span></span><br><span class="line">long_variable = <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><p>  <strong>pycharm 自动化格式默认样式已经支持上述所有格式。</strong></p><h1 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h1><ul><li><p>避免行尾空白。因为它们通常不可见，容易导致混淆，比如，\ 后面跟了一个空格，它就不是一个有效的续行符了。很多编辑器不保存行尾空白，CPython项目中也设置了commit 前检查，以拒绝行尾空白的存在。</p></li><li><p>在这些二元操作符的两边放置一个空格：赋值（= ）、增强赋值（+= ，-= 等）、比较（==、 &lt;、 &gt;、 !=、 &lt;&gt;、 &lt;=、&gt;=、in、not in、is、is not）、布尔（and、or、not ）。</p></li><li><p>如果使用了不同优先级的操作符，在低优先级操作符周围增加空格。不要使用多个空格，<strong>二元运算符两侧空格数量相等</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">submitted += <span class="number">1</span></span><br><span class="line">x = x*<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">hypot2 = x*x + y*y</span><br><span class="line">c = (a+b) * (a-b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">submitted +=<span class="number">1</span></span><br><span class="line">x = x * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">hypot2 = x * x + y * y</span><br><span class="line">c = (a + b) * (a - b)</span><br></pre></td></tr></table></figure></li><li><p>函数(类型)注释应该遵循冒号的使用规则。如果存在 - &gt; 箭头，应该在 - &gt; 箭头周围留出空格。 （有关函数注释的更多信息，请参阅下面的函数注释。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input: AnyStr)</span>:</span> ... <span class="comment"># 参数类型注释</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">()</span> -&gt; AnyStr:</span> ... <span class="comment"># 返回值类型注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input:AnyStr)</span>:</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">()</span>-&gt;PosInt:</span> ...</span><br></pre></td></tr></table></figure></li><li><p>当 = 符号用于表示关键字参数或参数默认值时，它周围不要使用空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> magic(r=real, i=imag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure><p>如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(sep: AnyStr = None)</span>:</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input: AnyStr, sep: AnyStr = None, limit=<span class="number">1000</span>)</span>:</span> ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input: AnyStr=None)</span>:</span> ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(input: AnyStr, limit = <span class="number">1000</span>)</span>:</span> ...</span><br></pre></td></tr></table></figure></li><li><p>不鼓励使用复合语句（同一行有多条语句）。</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>:</span><br><span class="line">    do_blah_thing()</span><br><span class="line">do_one()</span><br><span class="line">do_two()</span><br><span class="line">do_three()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐做法</span></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: do_blah_thing()</span><br><span class="line">do_one(); do_two(); do_three()</span><br></pre></td></tr></table></figure></li><li><p>尽管有时可以在if/for/while的同一行跟一句代码，但在有多条子句的语句中不要如此，避免折叠长行！</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最好不要</span></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst: total += x</span><br><span class="line"><span class="keyword">while</span> t &lt; <span class="number">10</span>: t = delay()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对不要</span></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: do_blah_thing()</span><br><span class="line"><span class="keyword">else</span>: do_non_blah_thing()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: something()</span><br><span class="line"><span class="keyword">finally</span>: cleanup()</span><br><span class="line"></span><br><span class="line">do_one(); do_two(); do_three(long, argument,</span><br><span class="line">                             list, like, this)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>: one(); two(); three()</span><br><span class="line">**pycharm 默认已经支持该格式。**</span><br></pre></td></tr></table></figure></li></ul><p><strong>pycharm 自动化格式默认样式已经支持上述所有格式。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第5小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="空格" scheme="http://jihuawisdom.cn/tags/%E7%A9%BA%E6%A0%BC/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(4)-字符串引号</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%95%E5%8F%B7/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-4-字符串引号/</id>
    <published>2019-07-11T14:53:39.000Z</published>
    <updated>2019-07-11T15:33:06.673Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第4小节，其他小节可以通过下面链接阅读。</p><a id="more"></a><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.字符串引号</p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><h2 id="字符串引号"><a href="#字符串引号" class="headerlink" title="字符串引号"></a>字符串引号</h2><p>Python中，单引号字符串和双引号字符串是一样的，本PEP对此不提供任何建议，建议选择一条规则并坚持下去。但当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠，这可以提高可读性。</p><p>三引号字符串的使用，与PEP 257 文档字符串规范一致，总是使用双引号字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第4小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="字符串引号" scheme="http://jihuawisdom.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%95%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(3)-代码布局</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-3-%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-3-代码布局/</id>
    <published>2019-07-11T14:14:34.000Z</published>
    <updated>2019-07-12T11:26:28.015Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第3小节，其他小节可以通过下面链接阅读。</p><a id="more"></a><p><a href="/2019/07/11/python代码样式指南-1-2">1.介绍</a></p><p><a href="/2019/07/11/python代码样式指南-1-2">2.本指南不适用的情况</a></p><p>3.代码布局</p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><h1 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h1><p>每个缩进级别使用4个空格。<br>连续行应该对齐包裹的元素，或者垂直对齐 Python 隐式换行连接中的圆括号、中括号、大括号内的元素，或者使用悬挂缩进(悬挂缩进就是括号内的元素从下一行开始)。</p><p>使用悬挂缩进应注意以下几点；</p><ul><li><p>第一行没有参数并且使用更多的缩进来区别它本身和连续行。</p><p>风格良好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与起始分界符对齐</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加4个空格（额外的缩进级别）以区分参数与其他语句</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="function"><span class="params">        var_four)</span>:</span></span><br><span class="line">    print(var_one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 悬挂应该增加一个缩进级别</span></span><br><span class="line">foo = long_function_name(</span><br><span class="line">    var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br></pre></td></tr></table></figure><p>风格不良：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用垂直对齐时禁止在第一行上放置参数</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为无法区分参数和语句，所以需要进一步缩进</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="function"><span class="params">    var_four)</span>:</span></span><br><span class="line">    print(var_one)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>对于连续行，4个空格规则是可选的，比如可以缩进2个空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 悬挂缩进*可以*缩进到除4个空格以外的其他位置.</span></span><br><span class="line">foo = long_function_name(</span><br><span class="line">  var_one, var_two,</span><br><span class="line">  var_three, var_four)</span><br></pre></td></tr></table></figure></li><li><p>if语句条件块非常长需要编写多行时，需要注意的是，两个字符组成的关键字（例如if），加上一个空格，加上开括号正好4个字符，此时为多行条件的后续行创建的也是4个空格的缩进。这和嵌入if内的缩进语句会产生视觉冲突，因为它们也是缩进4个空格。这个点PEP没有明确说明如何（是否）进一步区分条件行和if语句内的嵌入行。这种情况下，可以接受的选项包括但不仅限于下面几种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有额外的缩进</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一行注释，通过注释的语法高亮来做区分</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    <span class="comment"># Since both conditions are true, we can frobnicate.</span></span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在条件的连续行上增加一个缩进</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing</span><br><span class="line">        <span class="keyword">and</span> that_is_another_thing):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>多行结构中的结束花括号/中括号/圆括号可以在列表最后一行的第一个非空白字符下排列，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    ]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>或者是排列在开始多行结构的第一个字符下面（pycharm 默认采用的这种），如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h1 id="制表符还是空格？"><a href="#制表符还是空格？" class="headerlink" title="制表符还是空格？"></a>制表符还是空格？</h1><p>空格是缩进方法的首选。<br>制表符仅用于与已经用制表符做缩进的代码保持一致。<br>Python3不允许混用制表符和空格来缩进。<br>Python2代码混用制表符和空格缩进，将被转化为只使用空格。<br>调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！</p><h1 id="行的最大长度"><a href="#行的最大长度" class="headerlink" title="行的最大长度"></a>行的最大长度</h1><p>将所有的行都限制为最多79个字符。</p><p>对于长文本块（比如文档字符串或注释），行的长度应该限制在72个字符。</p><p>限制了编辑器窗口宽度才可以并排打开多个文件，比如，使用代码审查工具并排显示相邻列的两个版本。</p><p>大多数工具默认的换行折叠会破坏代码的可视化结构，使其更难以理解。选择79个字符是因为有些编辑器的窗口宽度设置为80个字符，即使该工具在最后一列中放置标记字形，也可以正常显示。一些基于网络的工具可能不会提供动态的自动换行。</p><p>有些团队强烈喜欢较长的行长度。对于专门维护的代码或主要由一个团队的维护的代码，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。</p><p>Python标准库采取的保守做法，要求行长度限制为79个字符（文档字符串/注释到72个字符）。</p><p>折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面包裹小括号来变成多行。对于连续行使用反斜杠更好。</p><p>反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/some/file/you/want/to/read'</span>) <span class="keyword">as</span> file_1, \</span><br><span class="line">     open(<span class="string">'/path/to/some/file/being/written'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file_2:</span><br><span class="line">    file_2.write(file_1.read())</span><br></pre></td></tr></table></figure><p>（为进一步思考With语句的多行缩进，见前面多行if语句的讨论。）</p><p>另一个这样的例子是assert语句。</p><p>另外注意，确保适当的连续行缩进。</p><h1 id="换行应该在二元操作符的前面还是后面？"><a href="#换行应该在二元操作符的前面还是后面？" class="headerlink" title="换行应该在二元操作符的前面还是后面？"></a>换行应该在二元操作符的前面还是后面？</h1><p>过去几十年我们都是推荐把换行放在二元操作符的后面。但是这种做法会有两种破坏可读性的问题：</p><ol><li><p>多个二元操作符在屏幕上不在同一列；</p></li><li><p>你想知道对一个被操作的对象做了什么操作，需要向上找一行。这导致你的眼睛不得不上下往返很多次才能搞清楚哪个数字是被加的，哪个数字是被减的：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐的做法，操作符位置远离操作数</span></span><br><span class="line">income = (gross_wages +</span><br><span class="line">          taxable_interest +</span><br><span class="line">          (dividends - qualified_dividends) -</span><br><span class="line">          ira_deduction -</span><br><span class="line">          student_loan_interest)</span><br></pre></td></tr></table></figure><p>为了解决可读性问题，数学家和印刷业者通常是<strong>在二元操作符之前换行</strong>的。Donald Knuth在他的《计算机与排版》系列文章中解释了这个传统规则：“虽然写在一段话中的公式经常在二元操作符的后面换行，但是单独展示的公式通常是在二元操作符的前面换行。”</p><p>遵循数学传统，通常会产生更易读的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 好的做法：很容易看出操作符和被操作对象之间的关系</span></span><br><span class="line">income = (gross_wages</span><br><span class="line">          + taxable_interest</span><br><span class="line">          + (dividends - qualified_dividends)</span><br><span class="line">          - ira_deduction</span><br><span class="line">          - student_loan_interest)</span><br></pre></td></tr></table></figure><p>在 Python 代码中，只要约定在本地一致，就允许在二元运算符之前或之后中断。对于新代码，建议使用Knuth的样式</p><h1 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h1><p>顶级函数、类的定义有两行空行包裹。</p><p>类内部的函数定义有一个空行包裹。</p><p>可以使用额外的空行（谨慎地）来分离相关的功能组。组内相关代码的行（例如：一组虚拟实现）之间不使用空行。</p><p>在函数中也可以使用空行（谨慎地）来分割不同逻辑部分。</p><p>Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。</p><h1 id="源文件编码"><a href="#源文件编码" class="headerlink" title="源文件编码"></a>源文件编码</h1><p>Python核心发布版本中的代码应该一直使用<strong>UTF-8编码</strong>（或Python2中用<strong>ASCII</strong>）。<br>文件使用ASCII（Python2中）或UTF-8（Python3中）不应有编码声明。</p><p>在标准库中，非默认编码仅用于测试目的，或注释、文档字符串需要提及包含非ASCII字符的作者名；否则，使用\x，\u，\U，或\N是字符串中包含非ASCII数据的首先方式。</p><p>Python3.0及以上版本中，为标准库（参见PEP 3131）规定以下策略：<strong>Python标准库中的所有标识符必须使用ASCII标识符</strong>，并尽可能使用英文单词（在很多例子中，使用非英文的缩写和专业术语）。另外，字符串和注释必须用ASCII。</p><p>仅有的例外是：</p><p>（a）测试非ASCII功能的测试用例</p><p>（b）作者名字。名字不是基于拉丁字母表的作者名，必须提供一个他们名字的拉丁字母表的音译。</p><p>鼓励全球受众的开源项目采用类似的政策。</p><h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><ul><li>导入通常是单独一行，例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 风格良好</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 风格不良</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br></pre></td></tr></table></figure><p>这样也可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br></pre></td></tr></table></figure><ul><li><p>导入应该位于文件顶部，在模块注释和文档字符串之后，在模块全局变量和常量之前。</p><p>导入应该按照以下顺序分组：</p><ol><li>标准库导入</li><li>相关的第三方导入</li><li>特定的本地应用/库导入</li></ol><p>在每个导入组之间放一行空行。</p></li><li><p><strong>建议使用绝对导入</strong>，如果导入系统配置不正确时（例如，当包中的目录最终出现在sys.path上时），绝对导入具有更好的可读性，并且往往表现更好（或至少提供更好的错误消息）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mypkg.sibling</span><br><span class="line"><span class="keyword">from</span> mypkg <span class="keyword">import</span> sibling</span><br><span class="line"><span class="keyword">from</span> mypkg.sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure><p><strong>显式相对导入也是可接受的方法</strong>，尤其是在处理复杂的包布局时，使用绝对导入会不必要地冗长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> sibling</span><br><span class="line"><span class="keyword">from</span> .sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure><p>标准库代码应该避免复杂包布局并使用绝对导入。<br><strong>隐式的相对导入应该永远不被使用</strong>，并且在Python3中已经移除。</p></li><li><p>从一个包含类的模块中导入类时，通常下面这样是好的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myclass <span class="keyword">import</span> MyClass</span><br><span class="line"><span class="keyword">from</span> foo.bar.yourclass <span class="keyword">import</span> YourClass</span><br></pre></td></tr></table></figure><p>如果这种写法导致本地名字冲突，那么就这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myclass</span><br><span class="line"><span class="keyword">import</span> foo.bar.yourclass</span><br></pre></td></tr></table></figure><p>并使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”来访问。</p></li><li><p><strong>避免使用通配符导入</strong>（from <module> import *），因为用它们会不清楚命名空间中存在哪些名称，使读者和许多自动化工具混淆。通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口，该接口从一个可选的加速器模块定义并且哪些定义将被重写提前并不知道）。</module></p><p>用这种方式重新命名，下面的有关公共和内部接口的指南仍适用。</p></li></ul><h1 id="模块级别的内置属性"><a href="#模块级别的内置属性" class="headerlink" title="模块级别的内置属性"></a>模块级别的内置属性</h1><p>模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，<strong>应该放置在模块的文档字符串后，任意import语句之前</strong>，from __future__导入除外。Python要求futures导入必须在除文档字符串外任何模块代码之前。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""This is the example module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This module does stuff.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> barry_as_FLUFL</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">__version__ = <span class="string">'0.1'</span></span><br><span class="line">__author__ = <span class="string">'Cardinal Biggles'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第3小节，其他小节可以通过下面链接阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="缩进" scheme="http://jihuawisdom.cn/tags/%E7%BC%A9%E8%BF%9B/"/>
    
      <category term="导入" scheme="http://jihuawisdom.cn/tags/%E5%AF%BC%E5%85%A5/"/>
    
      <category term="空格" scheme="http://jihuawisdom.cn/tags/%E7%A9%BA%E6%A0%BC/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="换行" scheme="http://jihuawisdom.cn/tags/%E6%8D%A2%E8%A1%8C/"/>
    
      <category term="文件编码" scheme="http://jihuawisdom.cn/tags/%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81/"/>
    
      <category term="代码布局" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>python代码样式指南(1)(2)</title>
    <link href="http://jihuawisdom.cn/2019/07/11/python%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-1-2/"/>
    <id>http://jihuawisdom.cn/2019/07/11/python代码样式指南-1-2/</id>
    <published>2019-07-11T13:44:29.000Z</published>
    <updated>2019-07-12T09:21:05.201Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">PEP:</th><th>8</th></tr></thead><tbody><tr><td style="text-align:left">Created:</td><td>2001-07-05</td></tr><tr><td style="text-align:left">Post-History:</td><td>2001-07-05, 2013-08-01</td></tr></tbody></table><p>PEP 8共有9个小节，本文是第1、2小节。</p><p>1.介绍</p><p>2.本指南不适用的情况</p><p><a href="/2019/07/11/python代码样式指南-3-代码布局/">3.代码布局</a></p><p>4.<a href="/2019/07/11/python代码样式指南-4-字符串引号/">字符串引号</a></p><p>5.<a href="/2019/07/11/python代码样式指南-5-表达式和语句中的空格/">表达式和语句中的空格</a></p><p>6.<a href="/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/">什么时候使用尾部逗号</a></p><p>7.<a href="/2019/07/11/python代码样式指南-7-注释/">注释</a></p><p>8.<a href="/2019/07/11/python代码样式指南-8-命名规范/">命名规范</a></p><p>9.<a href="/2019/07/11/python代码样式指南-9-程序设计建议/">程序设计建议</a></p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文档（PEP8）提供了，Python 主发行版和Python标准库中的 Python 代码的编码约定。另外，在 Python 的 C 实现中，C 代码的编码风格指南请查看PEP 7。 </p><p>本文和PEP 257（Docstring Conventions）都是改编自 Guido 原来写的 Python 编码风格指南，还有一部分改编自 <a href="http://barry.warsaw.us/software/STYLEGUIDE.txt" target="_blank" rel="noopener">Barry 的编码风格指南[2]</a>。 </p><p>编码风格指南会随着时间的推移逐渐发展，过去的约定会因语言本身的变化而过时。 </p><p>许多项目都有自己的编码风格指南，如果发生任何冲突，此类项目特定指南优先于本指南。</p><h1 id="本指南不适用的情况"><a href="#本指南不适用的情况" class="headerlink" title="本指南不适用的情况"></a>本指南不适用的情况</h1><p>Guido 认为，代码阅读的次数远高于编写的次数。所以本指南旨在使各种地方的 Python 代码风格保持一致，来提高代码的可读性。正如 PEP 20 所说，“代码可读性非常重要”。</p><p>本风格指南是关于代码风格一致性的内容，虽然代码风格与本指南中的代码风格保持一致很重要，但同一个项目中的代码风格保持一致更重要，一个模块或功能中的代码风格保持一致最重要。</p><p>大家还需要知道风格指南也有不适用的时候。当你怀疑风格指南不适用时，要自己作出最佳的判断。看看其他的例子，并决定什么是最好的。不要犹豫，尽管发问！</p><p>特别是：不要只为遵从这个PEP而打破向后兼容性！</p><p>可以忽视本指南中既定规则的情况有：<br>1、应用指南会降低代码的可读性，即使对于那些习惯遵照这个 PEP 来阅读代码的人来说。<br>2、会破坏与周围代码的一致性（可能是历史原因）——虽然这也是收拾别人烂摊子的好机会（在真正的XP风格中）。<br>3、因为有问题的代码早于指南的引入，又没有其他理由可以修改该代码。<br>4、代码需要兼容 Python 老版本中本风格指南不建议使用的 Python 特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;PEP:&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Created:&lt;/td&gt;
&lt;td&gt;2001-07-05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Post-History:&lt;/td&gt;
&lt;td&gt;2001-07-05, 2013-08-01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PEP 8共有9个小节，本文是第1、2小节。&lt;/p&gt;
&lt;p&gt;1.介绍&lt;/p&gt;
&lt;p&gt;2.本指南不适用的情况&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/07/11/python代码样式指南-3-代码布局/&quot;&gt;3.代码布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;/2019/07/11/python代码样式指南-4-字符串引号/&quot;&gt;字符串引号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;/2019/07/11/python代码样式指南-5-表达式和语句中的空格/&quot;&gt;表达式和语句中的空格&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.&lt;a href=&quot;/2019/07/11/python代码样式指南-6-什么时候使用尾部逗号/&quot;&gt;什么时候使用尾部逗号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7.&lt;a href=&quot;/2019/07/11/python代码样式指南-7-注释/&quot;&gt;注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8.&lt;a href=&quot;/2019/07/11/python代码样式指南-8-命名规范/&quot;&gt;命名规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9.&lt;a href=&quot;/2019/07/11/python代码样式指南-9-程序设计建议/&quot;&gt;程序设计建议&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jihuawisdom.cn/categories/python/"/>
    
    
      <category term="代码风格" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="pep8" scheme="http://jihuawisdom.cn/tags/pep8/"/>
    
      <category term="缩进" scheme="http://jihuawisdom.cn/tags/%E7%BC%A9%E8%BF%9B/"/>
    
      <category term="空行" scheme="http://jihuawisdom.cn/tags/%E7%A9%BA%E8%A1%8C/"/>
    
      <category term="导入" scheme="http://jihuawisdom.cn/tags/%E5%AF%BC%E5%85%A5/"/>
    
      <category term="空格" scheme="http://jihuawisdom.cn/tags/%E7%A9%BA%E6%A0%BC/"/>
    
      <category term="注释" scheme="http://jihuawisdom.cn/tags/%E6%B3%A8%E9%87%8A/"/>
    
      <category term="命名规范" scheme="http://jihuawisdom.cn/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    
      <category term="代码样式" scheme="http://jihuawisdom.cn/tags/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
</feed>
