<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python代码样式指南(4)-字符串引号]]></title>
    <url>%2F2019%2F07%2F11%2Fpython%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%95%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[PEP: 8 Created: 2001-07-05 Post-History: 2001-07-05, 2013-08-01 PEP 8共有9个小节，本文是第4小节，其他小节可以通过下面链接阅读。 1.介绍 2.本指南不适用的情况 3.代码布局 4.字符串引号 5.表达式和语句中的空格 6.什么时候使用尾部逗号 7.注释 8.命名规范 9.程序设计建议 字符串引号Python中，单引号字符串和双引号字符串是一样的，本PEP对此不提供任何建议，建议选择一条规则并坚持下去。但当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠，这可以提高可读性。 三引号字符串的使用，与PEP 257 文档字符串规范一致，总是使用双引号字符。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pep8</tag>
        <tag>代码样式</tag>
        <tag>代码风格</tag>
        <tag>字符串引号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python代码样式指南(3)-代码布局]]></title>
    <url>%2F2019%2F07%2F11%2Fpython%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-3-%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[PEP: 8 Created: 2001-07-05 Post-History: 2001-07-05, 2013-08-01 PEP 8共有9个小节，本文是第3小节，其他小节可以通过下面链接阅读。 1.介绍 2.本指南不适用的情况 3.代码布局 4.字符串引号 5.表达式和语句中的空格 6.什么时候使用尾部逗号 7.注释 8.命名规范 9.程序设计建议 代码布局 缩进每个缩进级别使用4个空格。连续行应该对齐包裹的元素，或者垂直的使用Python的隐式行连接圆括号、中括号、大括号内的元素，或者使用悬挂缩进。使用悬挂缩进应注意以下几点； 第一行没有参数并且使用更多的缩进来区别它本身和连续行。 风格良好： 1234567891011121314# 与起始分界符对齐foo = long_function_name(var_one, var_two, var_three, var_four)# 添加4个空格（额外的缩进级别）以区分参数与其他语句def long_function_name( var_one, var_two, var_three, var_four): print(var_one)# 悬挂应该增加一个缩进级别foo = long_function_name( var_one, var_two, var_three, var_four) 风格不良： 123456789# 不使用垂直对齐时禁止在第一行上放置参数foo = long_function_name(var_one, var_two, var_three, var_four)# 因为无法区分参数和语句，所以需要进一步缩进def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 对于连续行，4个空格规则是可选的，比如可以缩进2个空格。可选的： 1234# 悬挂缩进*可以*缩进到除4个空格以外的其他位置.foo = long_function_name( var_one, var_two, var_three, var_four) if语句条件块非常长需要编写多行时，需要注意的是，两个字符组成的关键字（例如if），加上一个空格，加上开括号正好4个字符，此时为多行条件的后续行创建的也是4个空格的缩进。这和嵌入if内的缩进语句会产生视觉冲突，因为它们也是缩进4个空格。这个点PEP没有明确说明如何（是否）进一步区分条件行和if语句内的嵌入行。这种情况下，可以接受的选项包括但不仅限于下面几种： 123456789101112131415# 没有额外的缩进if (this_is_one_thing and that_is_another_thing): do_something()# 增加一行注释，通过注释的语法高亮来做区分if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something()# 在条件的连续行上增加一个缩进if (this_is_one_thing and that_is_another_thing): do_something() 多行结构中的结束花括号/中括号/圆括号可以在列表最后一行的第一个非空白字符下排列，如： 12345678my_list = [ 1, 2, 3, 4, 5, 6, ]result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 或者是排列在开始多行结构的第一个字符下面，如： 12345678my_list = [ 1, 2, 3, 4, 5, 6,]result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f',) 制表符还是空格？空格是缩进方法的首选。制表符仅用于与已经用制表符做缩进的代码保持一致。Python3不允许混用制表符和空格来缩进。Python2代码混用制表符和空格缩进，将被转化为只使用空格。调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！ 行的最大长度将所有的行都限制为最多79个字符。 对于长文本块（比如文档字符串或注释），行的长度应该限制在72个字符。 限制了编辑器窗口宽度才可以并排打开多个文件，比如，使用代码审查工具并排显示相邻列的两个版本。 大多数工具默认的换行折叠会破坏代码的可视化结构，使其更难以理解。选择79个字符是因为有些编辑器的窗口宽度设置为80个字符，即使该工具在最后一列中放置标记字形，也可以正常显示。一些基于网络的工具可能不会提供动态的自动换行。 有些团队强烈喜欢较长的行长度。对于专门维护的代码或主要由一个团队的维护的代码，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。 Python标准库采取的保守做法，要求行长度限制为79个字符（文档字符串/注释到72个字符）。 折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面包裹小括号来变成多行。对于连续行使用反斜杠更好。 反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠： 123with open('/path/to/some/file/you/want/to/read') as file_1, \ open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) （为进一步思考With语句的多行缩进，见前面多行if语句的讨论。） 另一个这样的例子是assert语句。 另外注意，确保适当的连续行缩进。 换行应该在二元操作符的前面还是后面？过去几十年我们都是推荐把换行放在二元操作符的后面。但是这种做法会有两种破坏可读性的问题：1.多个二元操作符在屏幕上不在同一列，2.你想知道对一个被操作的对象做了什么操作，需要向上找一行。这导致你的眼睛不得不上下往返很多次才能搞清楚哪个数字是被加的，哪个数字是被减的： 123456# 不推荐的做法，操作符位置远离操作数income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 为了解决可读性问题，数学家和印刷业者通常是在二元操作符之前换行的。Donald Knuth在他的《计算机与排版》系列文章中解释了这个传统规则：“虽然写在一段话中的公式经常在二元操作符的后面换行，但是单独展示的公式通常是在二元操作符的前面换行。” 遵循数学传统，通常会产生更易读的代码： 123456# 好的做法：很容易看出操作符和被操作对象之间的关系income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 在Python代码中，只要约定在本地一致，就允许在二元运算符之前或之后中断。对于新代码，建议使用Knuth的样式 空行顶级函数、类的定义有两行空行包裹。 类内部的函数定义有一个空行包裹。 可以使用额外的空行（谨慎地）来分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。 在函数中也可以使用空行（谨慎地）来表示逻辑部分。 Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。 源文件编码Python核心发布版本中的代码应该一直使用UTF-8编码（或Python2中用ASCII）。文件使用ASCII（Python2中）或UTF-8（Python3中）不应有编码声明。 在标准库中，非默认编码仅用于测试目的，或注释、文档字符串需要提及包含非ASCII字符的作者名；否则，使用\x，\u，\U，或\N是字符串中包含非ASCII数据的首先方式。 Python3.0及以上版本中，为标准库（参见PEP 3131）规定以下策略：Python标准库中的所有标识符必须使用ASCII标识符，并尽可能使用英文单词（在很多例子中，使用非英文的缩写和专业术语）。另外，字符串和注释必须用ASCII。 仅有的例外是： （a）测试非ASCII功能的测试用例 （b）作者名字。名字不是基于拉丁字母表的作者名，必须提供一个他们名字的拉丁字母表的音译。 鼓励全球受众的开源项目采用类似的政策。 导入 导入通常是单独一行，例如： 123# 风格良好import osimport sys 12# 风格不良import sys, os 这样也可以： 1from subprocess import Popen, PIPE 导入应该位于文件顶部，在模块注释和文档字符串之后，在模块全局变量和常量之前。 导入应该按照以下顺序分组： 标准库导入 相关的第三方导入 特定的本地应用/库导入 在每个导入组之间放一行空行。 建议使用绝对导入，因为如果导入系统配置不正确（例如，当包中的目录最终出现在sys.path上时），它们具有更好的可读性并且往往表现更好（或至少提供更好的错误消息）： 123import mypkg.siblingfrom mypkg import siblingfrom mypkg.sibling import example 显式相对导入也是可接受的方法，尤其是在处理复杂的包布局时，使用绝对导入会不必要地冗长 12from . import siblingfrom .sibling import example 标准库代码应该避免复杂包布局并使用绝对导入。隐式的相对导入应该永远不被使用，并且在Python3中已经移除。 从一个包含类的模块中导入类时，通常下面这样是好的写法： 12from myclass import MyClassfrom foo.bar.yourclass import YourClass 如果这种写法导致本地名字冲突，那么就这样写： 12import myclassimport foo.bar.yourclass 并使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”来访问。 避免使用通配符导入（from import *），因为用它们会不清楚命名空间中存在哪些名称，使读者和许多自动化工具混淆。通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口，该接口从一个可选的加速器模块定义并且哪些定义将被重写提前并不知道）。 用这种方式重新命名，下面的有关公共和内部接口的指南仍适用。 模块级别的内置属性模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，应该放置在模块的文档字符串后，任意import语句之前，from __future__导入除外。Python要求futures导入必须在除文档字符串外任何模块代码之前。 12345678910111213"""This is the example module.This module does stuff."""from __future__ import barry_as_FLUFL__all__ = ['a', 'b', 'c']__version__ = '0.1'__author__ = 'Cardinal Biggles'import osimport sys]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pep8</tag>
        <tag>缩进</tag>
        <tag>导入</tag>
        <tag>空格</tag>
        <tag>代码样式</tag>
        <tag>代码风格</tag>
        <tag>文件编码</tag>
        <tag>代码布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python代码样式指南(1)(2)]]></title>
    <url>%2F2019%2F07%2F11%2Fpython%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97-1-2%2F</url>
    <content type="text"><![CDATA[PEP: 8 Created: 2001-07-05 Post-History: 2001-07-05, 2013-08-01 PEP 8共有9个小节，本文是第1、2小节。 介绍本文档（PEP8）提供了，Python 主发行版和Python标准库中的 Python 代码的编码约定。另外，在 Python 的 C 实现中，C 代码的编码风格指南请查看PEP 7。 本文和PEP 257（Docstring Conventions）都是改编自 Guido 原来写的 Python 编码风格指南，还有一部分改编自 Barry 的编码风格指南[2]。 编码风格指南会随着时间的推移逐渐发展，过去的约定会因语言本身的变化而过时。 许多项目都有自己的编码风格指南，如果发生任何冲突，此类项目特定指南优先于本指南。 本指南不适用的情况Guido 的一个重要见解是，代码阅读的次数远高于编写的次数。所以本指南旨在使各种不同地方的 Python 代码风格保持一致，来提高代码的可读性。正如 PEP 20 所说，“可读性很重要”。 本风格指南是关于代码风格一致性的内容，但要注意的是，虽然代码风格与本指南中的代码风格保持一致很重要，但同一个项目中的代码风格保持一致更重要，一个模块或功能中的代码风格保持一致最重要。 还需要大家知道风格指南也有不适用的时候。当你怀疑时，要作出你最佳的判断。看看其他的例子，并决定什么是最好的。不要犹豫，尽管发问！ 特别是：不要只为遵从这个PEP而打破向后兼容性！ 可以忽视本指南中既定规则的一些其他的好理由有：1、当应用指南会降低代码的可读性，即使对于那些习惯遵照这个 PEP 来阅读代码的人来说。2、会破坏与周围的代码保持一致性（可能是历史原因）——虽然这也是收拾别人烂摊子的好机会（在真正的XP风格中）。3、因为有问题的代码早于指南的引入，又没有其他理由可以修改该代码。4、代码需要兼容 Python 老版本中本风格指南不建议使用的 Python 特性。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pep8</tag>
        <tag>缩进</tag>
        <tag>空行</tag>
        <tag>导入</tag>
        <tag>空格</tag>
        <tag>注释</tag>
        <tag>命名规范</tag>
        <tag>代码样式</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pep8 Python代码样式指南 中文版]]></title>
    <url>%2F2019%2F07%2F11%2Fpython-pep8-%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[PEP: 8 Created: 2001-07-05 Post-History: 2001-07-05, 2013-08-01 [TOC] 介绍本文档提供了，Python 主发行版和标准库中的 Python 代码的编码约定。另外，在 Python 的 C 实现中，C 代码的编码风格指南请查看配套的PEP 7。 本文和PEP 257（Docstring Conventions）都是改编自 Guido 原来的 Python 编码风格指南，还有一些来自Barry的编码风格指南[2]。 编码风格指南会随着时间的推移逐渐发展，过去的约定会因语言本身的变化而过时。 许多项目都有自己的编码风格指南，如果发生任何冲突，此类项目特定指南优先于该项目。 墨守成规是愚蠢的做法Guido的一个重要见解是，代码阅读的次数远高于编写的次数。这里提供的指南旨在使各种不同地方的Python代码风格保持一致，来提高代码的可读性。正如PEP 20所说，“可读性很重要”。 风格指南是关于代码风格一致性的内容，虽然代码风格与本风格指南一致很重要，但同一个项目中的代码风格一致更重要，一个模块或功能中的代码风格一致最重要。 最重要的是：知道何时会不一致——有时风格指南就不适用了。怀疑时，作出你最佳的判断。看看其他的例子，并决定什么是最好的。不要犹豫，尽管发问！ 特别是：不要只为遵从这个PEP而打破向后兼容性！ 忽视既定指南的一些其他的好理由：1、当应用指南会降低代码的可读性，即使对于那些习惯遵照这个PEP来阅读代码的人来说。2、与周围的代码保持一致也会破坏它（可能是历史原因）——虽然这也是收拾别人烂摊子的好机会（在真正的XP风格中）。3、因为有问题的代码早于指南的引入，又没有其他理由可以修改该代码。4、代码需要兼容Python老版本中本风格指南不建议使用的Python特性。 代码布局缩进每个缩进级别使用4个空格。连续行应该对齐包裹的元素，或者垂直的使用Python的隐式行连接圆括号、中括号、大括号内的元素，或者使用悬挂缩进。使用悬挂缩进应注意以下几点； 第一行没有参数并且使用更多的缩进来区别它本身和连续行。 风格良好： 1234567891011121314# 与起始分界符对齐foo = long_function_name(var_one, var_two, var_three, var_four)# 添加4个空格（额外的缩进级别）以区分参数与其他语句def long_function_name( var_one, var_two, var_three, var_four): print(var_one)# 悬挂应该增加一个缩进级别foo = long_function_name( var_one, var_two, var_three, var_four) 风格不良： 123456789# 不使用垂直对齐时禁止在第一行上放置参数foo = long_function_name(var_one, var_two, var_three, var_four)# 因为无法区分参数和语句，所以需要进一步缩进def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 对于连续行，4个空格规则是可选的，比如可以缩进2个空格。可选的： 1234# 悬挂缩进*可以*缩进到除4个空格以外的其他位置.foo = long_function_name( var_one, var_two, var_three, var_four) if语句条件块非常长需要编写多行时，需要注意的是，两个字符组成的关键字（例如if），加上一个空格，加上开括号正好4个字符，此时为多行条件的后续行创建的也是4个空格的缩进。这和嵌入if内的缩进语句会产生视觉冲突，因为它们也是缩进4个空格。这个点PEP没有明确说明如何（是否）进一步区分条件行和if语句内的嵌入行。这种情况下，可以接受的选项包括但不仅限于下面几种： 123456789101112131415# 没有额外的缩进if (this_is_one_thing and that_is_another_thing): do_something()# 增加一行注释，通过注释的语法高亮来做区分if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something()# 在条件的连续行上增加一个缩进if (this_is_one_thing and that_is_another_thing): do_something() 多行结构中的结束花括号/中括号/圆括号可以在列表最后一行的第一个非空白字符下排列，如： 12345678my_list = [ 1, 2, 3, 4, 5, 6, ]result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 或者是排列在开始多行结构的第一个字符下面，如： 12345678my_list = [ 1, 2, 3, 4, 5, 6,]result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f',) 制表符还是空格？空格是缩进方法的首选。制表符仅用于与已经用制表符做缩进的代码保持一致。Python3不允许混用制表符和空格来缩进。Python2代码混用制表符和空格缩进，将被转化为只使用空格。调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！ 行的最大长度将所有的行都限制为最多79个字符。 对于长文本块（比如文档字符串或注释），行的长度应该限制在72个字符。 限制了编辑器窗口宽度才可以并排打开多个文件，比如，使用代码审查工具并排显示相邻列的两个版本。 大多数工具默认的换行折叠会破坏代码的可视化结构，使其更难以理解。选择79个字符是因为有些编辑器的窗口宽度设置为80个字符，即使该工具在最后一列中放置标记字形，也可以正常显示。一些基于网络的工具可能不会提供动态的自动换行。 有些团队强烈喜欢较长的行长度。对于专门维护的代码或主要由一个团队的维护的代码，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。 Python标准库采取的保守做法，要求行长度限制为79个字符（文档字符串/注释到72个字符）。 折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面包裹小括号来变成多行。对于连续行使用反斜杠更好。 反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠： 123with open('/path/to/some/file/you/want/to/read') as file_1, \ open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) （为进一步思考With语句的多行缩进，见前面多行if语句的讨论。） 另一个这样的例子是assert语句。 另外注意，确保适当的连续行缩进。 换行应该在二元操作符的前面还是后面？过去几十年我们都是推荐把换行放在二元操作符的后面。但是这种做法会有两种破坏可读性的问题：1.多个二元操作符在屏幕上不在同一列，2.你想知道对一个被操作的对象做了什么操作，需要向上找一行。这导致你的眼睛不得不上下往返很多次才能搞清楚哪个数字是被加的，哪个数字是被减的： 123456# 不推荐的做法，操作符位置远离操作数income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 为了解决可读性问题，数学家和印刷业者通常是在二元操作符之前换行的。Donald Knuth在他的《计算机与排版》系列文章中解释了这个传统规则：“虽然写在一段话中的公式经常在二元操作符的后面换行，但是单独展示的公式通常是在二元操作符的前面换行。” 遵循数学传统，通常会产生更易读的代码： 123456# 好的做法：很容易看出操作符和被操作对象之间的关系income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 在Python代码中，只要约定在本地一致，就允许在二元运算符之前或之后中断。对于新代码，建议使用Knuth的样式 空行顶级函数、类的定义有两行空行包裹。 类内部的函数定义有一个空行包裹。 可以使用额外的空行（谨慎地）来分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。 在函数中也可以使用空行（谨慎地）来表示逻辑部分。 Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。 源文件编码Python核心发布版本中的代码应该一直使用UTF-8编码（或Python2中用ASCII）。文件使用ASCII（Python2中）或UTF-8（Python3中）不应有编码声明。 在标准库中，非默认编码仅用于测试目的，或注释、文档字符串需要提及包含非ASCII字符的作者名；否则，使用\x，\u，\U，或\N是字符串中包含非ASCII数据的首先方式。 Python3.0及以上版本中，为标准库（参见PEP 3131）规定以下策略：Python标准库中的所有标识符必须使用ASCII标识符，并尽可能使用英文单词（在很多例子中，使用非英文的缩写和专业术语）。另外，字符串和注释必须用ASCII。 仅有的例外是： （a）测试非ASCII功能的测试用例 （b）作者名字。名字不是基于拉丁字母表的作者名，必须提供一个他们名字的拉丁字母表的音译。 鼓励全球受众的开源项目采用类似的政策。 导入 导入通常是单独一行，例如： 123# 风格良好import osimport sys 12# 风格不良import sys, os 这样也可以： 1from subprocess import Popen, PIPE 导入应该位于文件顶部，在模块注释和文档字符串之后，在模块全局变量和常量之前。 导入应该按照以下顺序分组： 标准库导入 相关的第三方导入 特定的本地应用/库导入 在每个导入组之间放一行空行。 建议使用绝对导入，因为如果导入系统配置不正确（例如，当包中的目录最终出现在sys.path上时），它们具有更好的可读性并且往往表现更好（或至少提供更好的错误消息）： 123import mypkg.siblingfrom mypkg import siblingfrom mypkg.sibling import example 显式相对导入也是可接受的方法，尤其是在处理复杂的包布局时，使用绝对导入会不必要地冗长 12from . import siblingfrom .sibling import example 标准库代码应该避免复杂包布局并使用绝对导入。隐式的相对导入应该永远不被使用，并且在Python3中已经移除。 从一个包含类的模块中导入类时，通常下面这样是好的写法： 12from myclass import MyClassfrom foo.bar.yourclass import YourClass 如果这种写法导致本地名字冲突，那么就这样写： 12import myclassimport foo.bar.yourclass 并使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”来访问。 避免使用通配符导入（from import *），因为用它们会不清楚命名空间中存在哪些名称，使读者和许多自动化工具混淆。通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口，该接口从一个可选的加速器模块定义并且哪些定义将被重写提前并不知道）。 用这种方式重新命名，下面的有关公共和内部接口的指南仍适用。 模块级别的内置属性模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，应该放置在模块的文档字符串后，任意import语句之前，from __future__导入除外。Python要求futures导入必须在除文档字符串外任何模块代码之前。 12345678910111213"""This is the example module.This module does stuff."""from __future__ import barry_as_FLUFL__all__ = ['a', 'b', 'c']__version__ = '0.1'__author__ = 'Cardinal Biggles'import osimport sys 字符串引号Python中，单引号字符串和双引号字符串是一样的，本PEP对此不提供任何建议，建议选择一条规则并坚持下去。但当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠，这可以提高可读性。 三引号字符串的使用，与PEP 257 文档字符串规范一致，总是使用双引号字符。 表达式和语句中的空格多余的空格避免以下情况使用多余的空格： 紧挨着小括号，中括号或大括号不需要空格 12Yes: spam(ham[1], &#123;eggs: 2&#125;)No: spam( ham[ 1 ], &#123; eggs: 2 &#125; ) 尾逗号和右括号之间不需要空格 12Yes: foo = (0,)No: bar = (0, ) 在逗号、分号或冒号前不需要空格： 12Yes: if x == 4: print x, y; x, y = y, xNo: if x == 4 : print x , y ; x , y = y , x 在切片中冒号是一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符）。在一个扩展切片中，两个冒号必须有相等数量的空格。例外：当一个切片参数被省略时，该空格被省略。 123456789101112# 推荐做法ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]ham[lower:upper], ham[lower:upper:], ham[lower::step]ham[lower+offset : upper+offset]ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]ham[lower + offset : upper + offset]#不推荐做法ham[lower + offset:upper + offset]ham[1: 9], ham[1 :9], ham[1:9 :3]ham[lower : : upper]ham[ : upper] 函数调用的参数列表的开始处左括号之前不需要空格： 12Yes: spam(1)No: spam (1) 索引或切片开始的左括号之前不需要空格： 12Yes: dct['key'] = lst[index]No: dct ['key'] = lst [index] 为了与另外的赋值（或其它）操作符对齐，分配不止一个空格。 123456789# 推荐做法x = 1y = 2long_variable = 3# 不推荐做法x = 1y = 2long_variable = 3 其它建议 避免行尾空白。因为它们通常不可见，容易导致混淆，比如，\ 后面跟了一个空格，它就不是一个有效的续行符了。很多编辑器不保存行尾空白，CPython项目中也设置了commit 前检查，以拒绝行尾空白的存在。 在这些二元操作符的两边放置一个空格：赋值（= ）、增强赋值（+= ，-= 等）、比较（==、 &lt;、 &gt;、 !=、 &lt;&gt;、 &lt;=、&gt;=、in、not in、is、is not）、布尔（and、or、not ）。 如果使用了不同优先级的操作符，在低优先级操作符周围增加空格。不要使用多个空格，二元运算符两侧空格数量相等。 12345678910111213# 推荐做法i = i + 1submitted += 1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b)# 不推荐做法i=i+1submitted +=1x = x * 2 - 1hypot2 = x * x + y * yc = (a + b) * (a - b) 函数注释应该遵循冒号的使用规则。如果存在 - &gt;箭头，应该在 - &gt;箭头周围留出空格。 （有关函数注释的更多信息，请参阅下面的函数注释。） 1234567# 推荐做法def munge(input: AnyStr): ...def munge() -&gt; AnyStr: ...# 不推荐做法def munge(input:AnyStr): ...def munge()-&gt;PosInt: ... 当=符号用于表示关键字参数或参数默认值时，它周围不要使用空格。 1234567# 推荐做法def complex(real, imag=0.0): return magic(r=real, i=imag)# 不推荐做法def complex(real, imag = 0.0): return magic(r = real, i = imag) 如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）。 1234567# 推荐做法def munge(sep: AnyStr = None): ...def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... # 不推荐做法def munge(input: AnyStr=None): ...def munge(input: AnyStr, limit = 1000): ... 不鼓励使用复合语句（同一行有多条语句）。 12345678910# 推荐做法if foo == 'blah': do_blah_thing()do_one()do_two()do_three()# 不推荐做法if foo == 'blah': do_blah_thing()do_one(); do_two(); do_three() 尽管有时可以在if/for/while的同一行跟一句代码，但在有多条子句的语句中不要如此，避免折叠长行！ 12345678910111213141516# 最好不要if foo == 'blah': do_blah_thing()for x in lst: total += xwhile t &lt; 10: t = delay()# 绝对不要if foo == 'blah': do_blah_thing()else: do_non_blah_thing()try: something()finally: cleanup()do_one(); do_two(); do_three(long, argument, list, like, this)if foo == 'blah': one(); two(); three() 什么时候使用尾部逗号尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）： 12345# 推荐做法FILES = ('setup.cfg',)# 不推荐做法FILES = 'setup.cfg', 当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。通常的用法是（比如列表）每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。 123456789101112# 推荐做法FILES = [ 'setup.cfg', 'tox.ini', ]initialize(FILES, error=True, )# 不推荐做法FILES = ['setup.cfg', 'tox.ini',]initialize(FILES, error=True,) 注释与代码相矛盾的注释比没有注释更糟糕。当代码修改时，始终优先更新注释！ 注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符。 如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。 除了最后一句之外，应该在多句注释中句尾的句号后边使用两个空格。 写英语注释时，遵循Strunk and White风格的英语写作规范。 非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。 块注释注释块通常适用于一些（或全部）紧跟其后的代码，并且与这些代码使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非是注释里面的文本有缩进）。 注释块内的段落之间由仅包含#的行隔开。 行内注释谨慎地使用行内注释。 行内注释就是和代码在同一行上的注释，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。 如果行内注释表达的意思显而易见，那么它就是不必要的。 不要这样做： 1x = x + 1 # Increment x 但有时，这样是有用的： 1x = x + 1 # Compensate for border 文档字符串编写好的文档字符串约定在PEP 257中。 所有公共模块、函数、类和方法都要求必须编写文档字符串。对非公共的方法不要求必须写文档字符串，但应该写个注释描述这个方法是做什么的。这些注释应该写在def行后面。 PEP 257描述了好的文档字符串规范。最重要的是，多行文档字符串以一行”””结束，例如： 1234"""Return a foobangOptional plotz says to frobnicate the bizbaz first.""" 对于只有一行的文档字符串，关闭”””在同一行上。 命名规范Python库的命名规范有点儿混乱，所以我们不会将他们变得完全一致——不过，这是目前推荐的命名标准。新模块和包（包括第三方框架）应该按这些标准书写，但对有不同的风格的已有库，保持内部一致性是首选。 根本原则用户可见的API的公开部分的名称，应该遵循用法反映的约定，而不是实现的约定。 描述性：命名风格有很多不同的命名风格。它有助于识别使用了什么样的命名风格，这与他们的作用无关。 下面这些是最常见的命名风格： b（单个小写字母） B（单个大写字母） 小写字符串 lower_case_with_underscores 带下划线的小写字符串 大写字符串 UPPER_CASE_WITH_UNDERSCORES 带下划线的大写字符串 CapitalizedWords 单词首字母大写的字符串（或 CapWords，或 CamelCase——因其字母看起来高低不平而得名[3]）。这有时也被称为StudlyCaps。 注意：当 CapWords 中使用了缩写，大写所有的缩写字母。因此HTTPServerError优于HttpServerError。 mixedCase 混用大小写的字符串（与首字母大写字符串不同的是它以小写字母开头） Capitalized_Words_With_Underscores 带下划线的首字母大写字符串（令人厌恶的！） 还有一种风格，使用简短独特的前缀与相关的名字组织在一起。Python中很少这样用，提一下是为了文档的完整性。例如，os.stat()函数返回一个元祖，它的元素名字通常类似st_mode，st_size，st_mtime等等这样。（这样做是为了强调与POSIX系统中调用的结构体的对应关系，这有助于熟悉这些的程序员。） X11库的所有的公开函数以X开头。Python中，这种风格通常认为是不必要的，因为属性名和方法名以对象名作前缀，而函数名以模块名作前缀。 另外，以下特殊形式，前置或后置下划线是公认的（一般可以与任何约定相结合）： _single_leading_underscore 单前置下划线：弱“内部使用”标志。例如 from M import *不会导入以下划线开头的对象。 single_trailing_underscore_ 单后置下划线：按惯例使用避免与Python关键字冲突，例如 1Tkinter.Toplevel(master, class_='ClassName') __double_leading_underscore 双前置下划线：当命名类属性时，调用时的名称会被修改（类FooBar中，__boo 会变成 _FooBar__boo；见下文）。 __double_leading_and_trailing_underscore__ 前置和后置都是双下划线：存在于用户控制的命名空间中的“魔法”的对象或属性。 例如：__init__，__import__ 或 __file__，除了在文档中使用他们，不要创造这样的名字。 规定性：命名约定避免采用的名字不要使用字符‘l’（小写字母el），‘O’（大写字母oh）或‘I’（大写字母eye）作为单字符变量名。 在某些字体中，这些字符与数字1和0是没有区别的。当想使用‘l’时，用‘L’代替。 ASCII兼容性标准库中使用的标识符必须与ASCII兼容，如PEP 3131的策略部分所描述。 包名和模块名模块应具有简短的全小写名称。可以在模块名中使用下划线来提高可读性。Python包也应该有简短的全小写名称，但不鼓励使用下划线。 当一个C或C++编写的扩展模块，伴随Python模块来提供了一个更高层次（例如更面向对象）的接口时，C/C++模块名有一个前导下划线（如_socket）。 类名类名通常使用单词首字母大写的CapWords（驼峰）规则。 在接口被记录并主要用作可调用的情况下，可以使用函数的命名约定。 请注意，内置名称有一个单独的约定：大多数内置名称是单个单词（或两个单词一起运行），CapWords约定仅用于异常名称和内置常量。 类型变量的名称类型变量的名称应该使用单词首字母大写的CapWords（驼峰）规则，并且尽量短，比如：T, AnyStr, Num。对于协变量和有协变行为的变量，建议添加后缀 __co 或者 __contra。 1234from typing import TypeVarVT_co = TypeVar('VT_co', covariant=True)KT_contra = TypeVar('KT_contra', contravariant=True) 异常名因为异常应该是类，所以异常的命名和类的命名规则一样。不过，如果这个异常确实是一个错误，异常名应该使用后缀“Error”。 全局变量名（希望这些变量是在一个模块内使用。）全局变量名命名约定和函数的命名约定相同。 模块设计为通过from M import *来使用，应使用 __all__ 机制防止导出全局变量，或使用加前缀的旧规则，为全局变量加下划线，来表明这些全局变量是“非公开模块”。 函数和变量名函数名应该是小写字母，必要时单词之间用下划线分开，以提高可读性。 变量名称遵循与函数名称相同的约定。 混合大小写只被允许用在这种风格已经占主导地位的上下文中（例如threading.py），以保持向后兼容性。 函数和方法参数使用self为实例化方法的第一个参数。 使用cls为类方法的第一个参数。 如果函数的参数名与保留关键字冲突，最好是为参数名添加一个后置下划线，而不是使用缩写或拼写错误。 因此class_ 比clss好。（也许使用同义词来避免更好。）。 方法名和实例变量采用函数命名规则：全部使用小写字母，必要时单词之间，用下划线分开，以提高可读性。 只对非公开的方法和实例变量使用一个前置下划线。 为了避免和子类命名冲突，使用两个前置下划线，来调用Python的名称修改规则。 Python用类名修改这些名字：如果类 Foo 有一个属性名为__a，通过 Foo.__a 不能访问，需要调用Foo._Foo__a来访问。通常，两个前置下划线只用来避免与子类的属性名冲突。 注意：关于__names 的使用存在一些争论（见下文）。 常量常量通常定义于模块级别，并且所有的字母都是大写，单词用下划线分开。例如MAX_OVERFLOW和TOTAL。 继承的设计务必要确定类的方法和实例变量（统称为：“属性”）是否公开，如果有疑问，那就选择非公开，因为以后把其变成公开比把一个公开属性改成非公开要容易。 public 属性是指你希望与你的类不相关的客户端使用的属性，您承诺避免向后不兼容的更改。非公开属性是指不打算由第三方使用的属性;您不能保证非公共属性不会更改甚至不会被删除。 在这里没有使用术语“private”，因为Python中没有真正私有的属性（python中没有通常的不必要的工作）。 另一类属性是属于“子类API”的属性（通常在其他语言中称为“protected”）。某些类被设计为基类，要么扩展，要么修改类的某些方面的行为。在设计这样的类的时候，要明确确定哪些属性是公开的，哪些属性是子类API的一部分，哪些属性是真正只在你的基类中使用。 出于这种考虑，下面有一份Python特色的指南： 公开属性应该没有前置下划线。 如果公开属性名和保留关键字冲突，给属性名添加一个后置下划线。这比缩写或错误拼写更可取。（然而，尽管有这样的规定，对于任何类的变量或参数，特别是类方法的第一个参数，‘cls’是首选的拼写方式） ​ 注1：参见上面对类方法的参数名的建议。 对于简单的公开数据属性，最好只暴露属性名，而不是使用复杂的访问器/修改器方法。记住，Python为未来增强提供了一条简单的途径，你应该发现简单的数据属性需要增加功能行为。在这种情况下，使用属性来隐藏简单数据属性访问语法后面的功能实现。 ​ 注1：属性仅工作于新风格的类。​ 注2：尽量保持功能行为无副作用，尽管如缓存等副作用通常是好的。​ 注3：计算开销较大的操作避免使用属性，属性表示法使调用者相信访问（相对）是廉价的。 如果确定你的类会被子类化，并有不希望子类使用的属性，考虑用两个前置下划线无后置下划线来命名它们。这将调用Python的名称修改算法，类名将被修改为属性名的一部分。当子类不无意间包括相同的属性名时，这有助于帮助避免属性名冲突。 ​ 注1：注意如果修改名称仅用于简单类名，一个子类使用相同的类名和属性名，仍然会有名字冲突。​ 注2：名称修改会带来一定的不便，如调试和 __getattr__()。然而，名称修改算法有良好的文档，也容易手工执行。​ 注3：不是每个人都喜欢名称修改。尽量平衡避免意外的名称冲突和高级调用者的可能。 公共和内部接口任何向后兼容性保证只适用于公共接口。因此，重要的是用户能够清楚地区分公开和内部接口。 文档接口被认为是公开的，除非文档明确声明他们是临时接口或内部接口，免除通常的向后兼容保证。所有非文档化的接口应假定为内部接口。 为了更好的支持自省，模块应该使用 __all__ 属性显示声明他们公开API的名字， __all__ 设置为一个空列表表示该模块没有公开API。即使 __all__ 设置的适当，内部接口（包，模块，类，函数，属性或者其它名字）仍应以一个前置下划线作前缀。 如果一个接口包含任何命名空间（包，模块，或类）都是内部的，那么这个接口被认为是内部接口。 导入名称也被认为是实现细节。其他模块不能依赖于对这些导入名称的间接访问，除非它们包含了模块的API的显式记录部分，例如 os.path 或从子模块公开功能的包的 __init__ 模块。 程序设计建议 代码应该以不影响Python的其他实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。 例如，不要依赖CPython为字符串连接 a + = b 或 a = a + b 形式的语句的高效实现。即使在CPython中，这种优化也很脆弱（它只适用于某些类型），并且在不使用引用计数的实现中根本不存在。在库的性能敏感部分，应该使用’.join（）形式。这将确保在各种实现中以线性时间进行连接。 像None这样的单例的比较应该总是使用 is 或者 is not，而不是相等的运算符。 另外，当你想要表达 if x is not None时，要避免写为if x ，因为在测试默认为None的变量或参数是否设置为其他值时，另一个值可能也具有在布尔上下文中为 false 的类型（例如容器）。 使用is not操作符而不是not...is...。虽然这两个表达式的功能相同，前者具有更好的可读性并且更受喜欢。 12345# 推荐写法if foo is not None:# 不推荐写法if not foo is None: 在使用丰富的比较实现排序操作时，最好实现所有六个操作 (__ne__，__lt__，__le__，__gt__，__ge__）而不是依靠其它代码只能进行一个特定的比较。 为了减少所涉及的工作量，functools.total_ordering()装饰器提供了一个工具来生成缺失的比较函数。 PEP 207表明，Python假定自反性规则。因此，编译器可以交换y &gt; x和x &lt; y，y &gt;= x和x &lt;= y，也可以交换参数x == y和x != y。sort() 和min() )操作保证使用 &lt; 运算符，而max() 函数使用 &gt; 运算符。不管怎样，最好实现所有六个操作，避免在其它情况下产生混淆。 使用def语句，而不是使用赋值语句将lambda表达式绑定到标识符上。 12345# 推荐写法def f(x): return 2*x# 不推荐写法f = lambda x: 2*x 第一种形式意味着所得的函数对象的名称是‘f’而不是一般的‘’。这在回溯和字符串表示中更有用。赋值语句的使用消除了lambda表达式可以提供显示def声明的唯一好处（例如它可以嵌在更大的表达式里面）。 从Exception而不是BaseException中派生出异常。直接继承BaseException是保留给那些捕捉几乎总是错的异常的。 基于可能需要捕获异常的代码的区别，来设计异常层次结构，而不是引发异常的位置。旨在以编程方式回答“出了什么问题？”的问题，而不是只说“问题产生了”（有关内置异常层次结构的本课程示例，请参阅PEP 3151） 类的命名规则适用于此，只是当异常确实是错误的时候，需要在异常类名添加“Error”后缀。非本地的流控制或其他形式的信号使用非错误的异常，不需要特殊的后缀。 适当使用异常链。Python3中，“raise X from Y”用来表明明确的更换而不失去原来追踪到的信息。 当故意替换一个内部异常（Python 2中使用“raise X”而Python 3.3+中使用“raise X from None”），确保相关的细节被转移到新的异常中（比如当转换KeyError为AttributeError时保留属性名，或在新的异常消息中嵌入原始异常的文本）。 Python 3中产生异常，使用raise ValueError(‘message’)替换python 2中的形式raise ValueError,’message’。 后一种形式是不合法的Python 3语法。 多亏了使用小括号的形式，当异常的参数很长或包含格式化字符传时，不必再使用续行符。 捕获异常时，尽可能提及特定的异常，而不是使用空的except：子句。例如，使用： 1234try: import platform_specific_moduleexcept ImportError: platform_specific_module = None 空的except：子句将捕获SystemExit和KeyboardInterrupt异常，这使得很难用Control-C来中断程序，也会掩饰其它的问题。如果想捕获会导致程序错误的所有异常，使用except Exception:（空异常相当于except BaseException:） 一条好的经验法则是将使用空‘except’子句限制为下面两种情况： 如果异常处理程序将打印出来或记录日志跟踪；至少用户能够意识到有错误发生。 如果代码需要做一些清理工作，但是随后让异常用 raise 抛出。处理这种情况用 try…finally 更好。 当用一个名字绑定捕获异常时，更喜欢Python2.6中添加的明确的名称绑定语法。 1234try: process_data()except Exception as exc: raise DataProcessingFailedError(str(exc)) 这是Python3中唯一支持的语法，可以避免旧的基于逗号的语法的歧义问题。 捕获操作系统错误时，我更喜欢 Python 3.3 中引入的显式异常层次结构，而不是内省errno值。 此外，对于所有try / except子句，将try子句限制为所需的绝对最小代码量。同样，这可以避免掩盖错误。 123456789101112131415# 推荐的做法try: value = collection[key]except KeyError: return key_not_found(key)else: return handle_value(value)# 不推荐的做法try: # Too broad! return handle_value(collection[key])except KeyError: # Will also catch KeyError raised by handle_value() return key_not_found(key) 当资源是特定代码段的本地资源时，请使用with语句以确保在使用后立即可靠地清除它。 try / finally语句也是可以接受的。 当除了获取和释放资源之外，还需要做其他一些事情的时候，应该通过单独的函数或方法调用上下文管理器。例如： 1234567# 推荐的做法with conn.begin_transaction(): do_stuff_in_transaction(conn)# 不推荐的做法with conn: do_stuff_in_transaction(conn) 后者的例子没有提供任何信息表明 __enter__ 和 __exit__ 方法做了除了事务结束后关闭连接以外的其他什么事情。 在这种情况下，显式表达是很重要的。 返回语句保持一致。函数中的所有返回语句都有返回值，或都没有返回值。如果任意一个返回语句有返回值，那么任意没有返回值的返回语句应该明确指出return None，并且应该有显示的返回语句放在函数结尾（如果可以）。 123456789101112131415161718192021# 推荐的做法def foo(x): if x &gt;= 0: return math.sqrt(x) else: return Nonedef bar(x): if x &lt; 0: return None return math.sqrt(x)# 不推荐的做法def foo(x): if x &gt;= 0: return math.sqrt(x)def bar(x): if x &lt; 0: return return math.sqrt(x) 使用字符串方法代替string模块。 字符串方法总是更快并且与unicode字符串使用相同的API。如果必须向后兼容Python2.0以前的版本，可以无视这个原则。 使用&#39;&#39;.startswith()和&#39;&#39;.endswith()代替字符串切片来检查前缀和后缀。 startswith()和endswith()更清晰，更不容易出错。例如： 12Yes: if foo.startswith('bar'):No: if foo[:3] == 'bar': 对象类型的比较使用isinstance()代替直接比较类型。 12Yes: if isinstance(obj, int):No: if type(obj) is type(1): 当检查一个对象是否是字符串时，牢记它也可能是一个 unicode 字符串！Python 2中，str和unicode有共同的基类 basestring，所以你可以这么做： 1if isinstance(obj, basestring): 注意，Python3 中， unicode 和 basestring 不再存在（只有str），并且bytes对象不再是 string（而是一个integers序列） 对于序列（字符串，列表，元组），要充分利用空序列就是 false 的情况。 12345Yes: if not seq: if seq:No: if len(seq): if not len(seq): 不要书写依赖后置空格的字符串。这些后置空格在视觉上无法区分，并且有些编辑器（或最近 reindent.py）将去掉他们。 不要用 == 将布尔值与True或False进行比较。 123Yes: if greeting:No: if greeting == True:Worse: if greeting is True: 函数注释随着PEP 484的发布，函数注释的样式规则也发生了如下的变化： 为了向前兼容，Python 3代码中的函数注释应该优选使用PEP 484语法。 （上一节中有一些注释的格式的建议。） 不再鼓励使用先前在本PEP中推荐的注释样式。 但是，除stdlib外，现在鼓励在PEP 484规则内进行实践。例如，使用PEP 484样式类型的注释标记大型第三方库或应用程序，查看添加这些注释的容易程度，并观察它们的存在是否增加了代码可理解性。 Python标准库应该保守采用这样的注释，除非用于它们的新代码和大型重构。 对于想要使用不同的函数注释的代码，建议在PEP检查表单中对类型检查进行如下注释。 1# type: ignore 靠近文件顶部；这告诉类型检查器忽略所有注释。 （在PEP 484中可以找到更细粒度的禁用类型检查器的方法。） 像 linters、类型检查器都是可选的、单独的工具。默认情况下，Python解释器不应由于类型检查而发出任何消息，并且不应基于注释更改其行为。 不想使用类型检查器的用户可以自由地忽略它们。但是，一般第三方库包的用户可能希望在这些包上运行类型检查程序。为此，PEP 484建议使用存根文件：.pyi文件，检查类型的时候，类型检查程序读取 .pyi文件，而不是相应的.py文件。存根文件可以与库一起分发，也可以通过类型化仓库（与库作者的许可）单独分发。 对于需要向后兼容的代码，可以以注释的形式添加类型注释。参见PEP 484 [6]的相关章节 变量注释PEP 526引入了变量注释。它们的样式建议类似于上面描述的功能注释。 模块级变量，类和实例变量以及局部变量的注释在冒号后应该有一个空格（特质类型提示中的类型注释） 冒号前应该没有空格 如果变量右侧有赋值，在等号两侧应该各有一个空格 12345678910111213# 推荐的做法code: intclass Point: coords: Tuple[int, int] label: str = '&lt;unknown&gt;'# 不推荐的做法code:int # No space after coloncode : int # Space before colonclass Test: result: int=0 # No spaces around equality sign 尽管PEP 526 从 Python 3.6 开始被接受，但变量注释语法是所有 Python 版本的存根文件的首选语法（有关详细信息，请参阅PEP 484）]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pep8</tag>
        <tag>缩进</tag>
        <tag>空行</tag>
        <tag>导入</tag>
        <tag>空格</tag>
        <tag>注释</tag>
        <tag>命名规范</tag>
        <tag>代码样式</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
